<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="既然选择远方，便不顾风雨亦兼程">
<meta property="og:type" content="website">
<meta property="og:title" content="川山">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="川山">
<meta property="og:description" content="既然选择远方，便不顾风雨亦兼程">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yuanSchuan">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>川山</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">川山</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/21/%E8%AE%A1%E7%BD%91%E5%AE%9E%E9%AA%8C/%E8%AE%A1%E7%BD%91%E5%AE%9E%E9%AA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuanSchuan">
      <meta itemprop="description" content="既然选择远方，便不顾风雨亦兼程">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="川山">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/21/%E8%AE%A1%E7%BD%91%E5%AE%9E%E9%AA%8C/%E8%AE%A1%E7%BD%91%E5%AE%9E%E9%AA%8C/" class="post-title-link" itemprop="url">计网实验</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-21 23:56:21 / 修改时间：23:57:57" itemprop="dateCreated datePublished" datetime="2022-12-21T23:56:21+08:00">2022-12-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%80%9D%E7%A7%91%E8%AE%A1%E7%BD%91%E5%AE%9E%E9%AA%8C/" itemprop="url" rel="index"><span itemprop="name">思科计网实验</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-连接的线：设备不同用直通线-实线-相同用交叉线-虚线-。"><a href="#1-连接的线：设备不同用直通线-实线-相同用交叉线-虚线-。" class="headerlink" title="1. 连接的线：设备不同用直通线(实线),相同用交叉线(虚线)。"></a>1. 连接的线：设备不同用直通线(实线),相同用交叉线(虚线)。</h2><ul>
<li><p>1.比如主机与交换机用直线。</p>
</li>
<li><p>2.交换机与交换机用交叉线，路由器与路由器用交叉线。</p>
</li>
<li><p>3，交换机与路由用直线。</p>
</li>
</ul>
<hr>
<h2 id="2-所有的主机都需要配备ip地址和掩码才能通信，主机直接相连也不行-因为没有可用端口，即没有指定端口，收到的数据也会被丢弃-。"><a href="#2-所有的主机都需要配备ip地址和掩码才能通信，主机直接相连也不行-因为没有可用端口，即没有指定端口，收到的数据也会被丢弃-。" class="headerlink" title="2. 所有的主机都需要配备ip地址和掩码才能通信，主机直接相连也不行(因为没有可用端口，即没有指定端口，收到的数据也会被丢弃)。"></a>2. 所有的主机都需要配备ip地址和掩码才能通信，主机直接相连也不行(因为没有可用端口，即没有指定端口，收到的数据也会被丢弃)。</h2><p>需要注意的是，如果与路由器连接，那么网关需要填写路由器通向这个主机的端口ip，否则无法通信。</p>
<blockquote>
<p>tips1:网关是一个局域网与外部连接的窗口，需要配置网关交换机才知道将信息发往哪个外部地址</p>
</blockquote>
<blockquote>
<p>tip2:同一网段，相同的网络号，即掩码前的数字相同。比如192.56.3.1&#x2F;24和192.56.3.2&#x2F;24。因为前24位相同为同一网段。</p>
</blockquote>
<hr>
<h2 id="3-端口：作为不同设备间通信的窗口，要使得多个互联的设备能够通信，比如要给端口分配地址，局域网必须要有MAC-物理地址-，互联网-不同局域网间-必须有IP。"><a href="#3-端口：作为不同设备间通信的窗口，要使得多个互联的设备能够通信，比如要给端口分配地址，局域网必须要有MAC-物理地址-，互联网-不同局域网间-必须有IP。" class="headerlink" title="3. 端口：作为不同设备间通信的窗口，要使得多个互联的设备能够通信，比如要给端口分配地址，局域网必须要有MAC(物理地址)，互联网(不同局域网间)必须有IP。"></a>3. 端口：作为不同设备间通信的窗口，要使得多个互联的设备能够通信，比如要给端口分配地址，局域网必须要有MAC(物理地址)，互联网(不同局域网间)必须有IP。</h2><ul>
<li><p>1.进入端口：interface 端口名字</p>
</li>
<li><p>2.给端口配置IP地址:ip address ip地址 掩码</p>
</li>
<li><p>3.注意，端口配置完后不会自动开启端口功能，需要使用no shutdown开启端口功能</p>
</li>
</ul>
<hr>
<h2 id="4-局域网内的主机需要在同一网段才能通信，不同网段不能通信。同网段可以通过划分vlan虚拟局域网来实现同网段划分的效果。创建vlan指令如下"><a href="#4-局域网内的主机需要在同一网段才能通信，不同网段不能通信。同网段可以通过划分vlan虚拟局域网来实现同网段划分的效果。创建vlan指令如下" class="headerlink" title="4. 局域网内的主机需要在同一网段才能通信，不同网段不能通信。同网段可以通过划分vlan虚拟局域网来实现同网段划分的效果。创建vlan指令如下:"></a>4. 局域网内的主机需要在同一网段才能通信，不同网段不能通信。同网段可以通过划分vlan虚拟局域网来实现同网段划分的效果。创建vlan指令如下:</h2><ul>
<li><p>1.vlan id(id可以是任意数字)</p>
</li>
<li><p>2.name word(word可以是任意名字)</p>
</li>
<li><p>3.删除vlan:no vlan id(要删除的vlanid)</p>
</li>
<li><p>4.进入vlan:in vlan id，注意：这也是启动vlan(将down状态转化成up)</p>
</li>
</ul>
<p>注意1：vlan需要分配到具体的端口才有用，因为每个端口唯一连接一个主机，分配到具体端口相当于直接将该主机分配到某个虚拟局域网。</p>
<ul>
<li>5.将某个端口归类给Vlan(首先需要进入端口):1. interface 端口名 2. switchport access vlan vlanid</li>
</ul>
<p>注意2：要使得vlan之间相互通信，为该局域网的vlan分配ip，借助三层交换机进行路由，才能通信，过程为进入vlan,即in vlan id，后ip adress…，<br>注意是三层交换机,因为路由器是不可以进行vlan创建的，</p>
<h2 id="特别需要注意的是，给vlan配置ip后，该vlan下主机的网关是vlan的ip地址，并且主机ip地址要和vlan的ip地址处于同一网段。"><a href="#特别需要注意的是，给vlan配置ip后，该vlan下主机的网关是vlan的ip地址，并且主机ip地址要和vlan的ip地址处于同一网段。" class="headerlink" title="特别需要注意的是，给vlan配置ip后，该vlan下主机的网关是vlan的ip地址，并且主机ip地址要和vlan的ip地址处于同一网段。"></a>特别需要注意的是，给vlan配置ip后，该vlan下主机的网关是vlan的ip地址，并且主机ip地址要和vlan的ip地址处于同一网段。</h2><ul>
<li>6.使用trunk进行不同交换机间通信:分别在二层和三层交换机连接的两个端口配置trunk：switchport mode trunk</li>
</ul>
<p>当然，要将trunk转换成接口即:switchport mode access</p>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><h2 id="1-trunk是帮助不同交换机下相同vlan的通信（因为不同交换机下的相同vlan不配置trunk无法通信，原因在于交换机的端口也归属一个vlan，必须要配置trunk才能使得所有vlan通过该接口）"><a href="#1-trunk是帮助不同交换机下相同vlan的通信（因为不同交换机下的相同vlan不配置trunk无法通信，原因在于交换机的端口也归属一个vlan，必须要配置trunk才能使得所有vlan通过该接口）" class="headerlink" title="1.trunk是帮助不同交换机下相同vlan的通信（因为不同交换机下的相同vlan不配置trunk无法通信，原因在于交换机的端口也归属一个vlan，必须要配置trunk才能使得所有vlan通过该接口）"></a>1.trunk是帮助不同交换机下相同vlan的通信（因为不同交换机下的相同vlan不配置trunk无法通信，原因在于交换机的端口也归属一个vlan，必须要配置trunk才能使得所有vlan通过该接口）</h2><h2 id="2-路由可以帮助不同vlan进行路由-本质上是利用路由的ip寻址功能，因此vlan间要通信必须分配ip-。注意区分二者。"><a href="#2-路由可以帮助不同vlan进行路由-本质上是利用路由的ip寻址功能，因此vlan间要通信必须分配ip-。注意区分二者。" class="headerlink" title="2.路由可以帮助不同vlan进行路由(本质上是利用路由的ip寻址功能，因此vlan间要通信必须分配ip)。注意区分二者。"></a>2.路由可以帮助不同vlan进行路由(本质上是利用路由的ip寻址功能，因此vlan间要通信必须分配ip)。注意区分二者。</h2><hr>
<h2 id="5-路由不同网段-或不同局域网-通信需要路由：设置ip为-ip-address-ip地址-掩码"><a href="#5-路由不同网段-或不同局域网-通信需要路由：设置ip为-ip-address-ip地址-掩码" class="headerlink" title="5. 路由不同网段(或不同局域网)通信需要路由：设置ip为:ip address ip地址 掩码"></a>5. 路由不同网段(或不同局域网)通信需要路由：设置ip为:ip address ip地址 掩码</h2><ul>
<li><p>1.需要为路由器和路由器之间的端口设置ip地址，这两个ip地址需要在同一网段。</p>
</li>
<li><p>2.路由器和交换机连接，只需要为路由器连接的端口设置ip地址即可，交换机端不需要。</p>
</li>
<li><p>3.路由器连接的交换机A，交换机A局域网下面的主机需要和路由器连接交换机A的端口ip处于同一网段，并且填写的网关要是这个ip地址。</p>
</li>
<li><p>4.路由器需要配置静态路由表，格式为(目的地址 掩码 下一条地址),目的地址只需要填网络号即可，比如192.56.3.3&#x2F;24。目的地址为192.56.3.0。<br>而下一条地址不是本路由器的端口地址，而是本路由器接下来要传递的邻接路由器的端口ip,这个IP必须写全，比如192.56.1.2。</p>
</li>
</ul>
<p>配置静态路由的指令为:ip route 目的地址网络号 掩码 下一条地址</p>
<blockquote>
<p>tips:要删除静态路由在ip route改为no ip route即可</p>
</blockquote>
<ul>
<li>5.动态路由：这边使用rip动态路由协议进行动态路由</li>
</ul>
<p>指令1进入rip:router rip</p>
<p>指令2配置rip的网络号:network 网络号</p>
<blockquote>
<p>tips：注意，rip配置的是本路由器的网络号，需要将本路由器的哪个端口连接的网络与其他路由器互联,使用network 路由器端口网络号即可。</p>
</blockquote>
<p>另外可以使用version指令配置rip版本，默认为version 2</p>
<p>关于可变长子网使用，因为version 2默认为边界汇总，要使用可变长子网的指令为<br>no auto-summary</p>
<p>需要注意的是，存在交换机和路由一体的机器，目的是为了降低成本。因此需要接口转换，即将交换机口与路由器口互换。</p>
<ul>
<li><p>1.将交换机口换成路由器口：no switchport,换回则switchport.</p>
</li>
<li><p>2.配置ip的方法有两种：一种是将交换机端口转化成路由器端口配置成指定ip,另一种是将端口与虚拟局域网vlan绑定，然后配置vlanIP。后者可以<br>直接将虚拟局域网的整个作为传输目标，进而不用一个个配置。</p>
<ul>
<li><p>1.第一种直接用 1) interface 端口名  选择端口，然后 2) no switchport，转换模式，最后设置端口ip地址 3) ip address ip地址 掩码</p>
</li>
<li><p>2.第二种为 1) in vlan id 进入vlan，然后设置vlanip地址 2) ip address ip地址 掩码</p>
</li>
</ul>
</li>
</ul>
<p>最后，交换机要选择2811,因为前面的不能拓展端口</p>
<h2 id="一定要注意！！！！！！，这种一体复用交换机一定要使用ip-routing指令开启路由功能！！！！！！，否则配置完也无法使用。"><a href="#一定要注意！！！！！！，这种一体复用交换机一定要使用ip-routing指令开启路由功能！！！！！！，否则配置完也无法使用。" class="headerlink" title="一定要注意！！！！！！，这种一体复用交换机一定要使用ip routing指令开启路由功能！！！！！！，否则配置完也无法使用。"></a>一定要注意！！！！！！，这种一体复用交换机一定要使用ip routing指令开启路由功能！！！！！！，否则配置完也无法使用。</h2><hr>
<h1 id="以下的DHCP-DNS-HTTP老师并未使用命令指定，不过命令不难记，就是对应的名字-参数。"><a href="#以下的DHCP-DNS-HTTP老师并未使用命令指定，不过命令不难记，就是对应的名字-参数。" class="headerlink" title="以下的DHCP,DNS,HTTP老师并未使用命令指定，不过命令不难记，就是对应的名字+参数。"></a>以下的DHCP,DNS,HTTP老师并未使用命令指定，不过命令不难记，就是对应的名字+参数。</h1><h2 id="6-DHCP：用于动态的给主机分配ip-过段时间需要重新请求ip，以节省ip地址。一般而言，DHCP服务器与交换机连接"><a href="#6-DHCP：用于动态的给主机分配ip-过段时间需要重新请求ip，以节省ip地址。一般而言，DHCP服务器与交换机连接" class="headerlink" title="6.DHCP：用于动态的给主机分配ip,过段时间需要重新请求ip，以节省ip地址。一般而言，DHCP服务器与交换机连接"></a>6.DHCP：用于动态的给主机分配ip,过段时间需要重新请求ip，以节省ip地址。一般而言，DHCP服务器与交换机连接</h2><ol>
<li><p>从主机模块拖入Genetic,与一个交换机相连,点击打开，在config下的serveice中有DHCP配置。</p>
</li>
<li><p>主要：分别填入默认网关(交换机连接的路由器端口，这个是给所有的从这里获取ip的地址的网关)，填写分配开始地址。如果有DNS，填入DNS地址。</p>
</li>
<li><p>如果在同一局域网下，无需配置，如果在不同局域网下需要使用ip helper-address DHCP服务器地址,以下介绍ip helper-address服务器地址的注意点</p>
</li>
</ol>
<h2 id="注意-ip-helper-address必须配置在连接局域网的那个路由端口，如果是三级交换机的vlanip-那个就进入那个vlan使用该指令。"><a href="#注意-ip-helper-address必须配置在连接局域网的那个路由端口，如果是三级交换机的vlanip-那个就进入那个vlan使用该指令。" class="headerlink" title="注意:ip helper-address必须配置在连接局域网的那个路由端口，如果是三级交换机的vlanip,那个就进入那个vlan使用该指令。"></a>注意:ip helper-address必须配置在连接局域网的那个路由端口，如果是三级交换机的vlanip,那个就进入那个vlan使用该指令。</h2><hr>
<h2 id="7-DNS与HTTP：DNS提供网址与ip地址的转换-输入网址转化成ip地址-，进入指定ip地址，服务HTTP会返回一个html页面-当然，可以返回其他数据，看你渲染软件是什么，本质上都是字符串。"><a href="#7-DNS与HTTP：DNS提供网址与ip地址的转换-输入网址转化成ip地址-，进入指定ip地址，服务HTTP会返回一个html页面-当然，可以返回其他数据，看你渲染软件是什么，本质上都是字符串。" class="headerlink" title="7. DNS与HTTP：DNS提供网址与ip地址的转换(输入网址转化成ip地址)，进入指定ip地址，服务HTTP会返回一个html页面(当然，可以返回其他数据，看你渲染软件是什么，本质上都是字符串。)"></a>7. DNS与HTTP：DNS提供网址与ip地址的转换(输入网址转化成ip地址)，进入指定ip地址，服务HTTP会返回一个html页面(当然，可以返回其他数据，看你渲染软件是什么，本质上都是字符串。)</h2><ul>
<li><p>1.二者都在服务器confige的service下面</p>
</li>
<li><p>2.DNS配置中的name是网址(比如<a target="_blank" rel="noopener" href="http://www.xxxx.com),address是这个网址要转换的ip地址,当主机的dns配置为该dns服务器的ip地址时,会为该主机提供dns解析./">www.xxxx.com)，address是这个网址要转换的ip地址，当主机的DNS配置为该DNS服务器的ip地址时，会为该主机提供DNS解析。</a></p>
</li>
</ul>
<blockquote>
<p>注意，若使用dhcp则需要在dhcp配置dns地址</p>
</blockquote>
<ul>
<li>3.http：考点为在主机的浏览器中输入网址,经过DNS解析后去往该ip的服务器地址，该服务器开启http服务，则会返回数据该请求主机的浏览器进程。</li>
</ul>
<blockquote>
<p>开始http和dns的方法均在第一点，记得dhcp,dns,http要点on才会开启服务。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/16/python/python/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuanSchuan">
      <meta itemprop="description" content="既然选择远方，便不顾风雨亦兼程">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="川山">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/16/python/python/" class="post-title-link" itemprop="url">python基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-16 21:51:19" itemprop="dateCreated datePublished" datetime="2022-12-16T21:51:19+08:00">2022-12-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-16 12:10:19" itemprop="dateModified" datetime="2023-02-16T12:10:19+08:00">2023-02-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-一些基础python特点"><a href="#1-一些基础python特点" class="headerlink" title="1.一些基础python特点"></a>1.一些基础python特点</h2><ol>
<li><p>命名的和其他语言一样，第一个字符必须是字母或者_</p>
</li>
<li><p>‘’,””都表示字符串，python没有char类型，只有字符串类型。并且使用(哪怕在其他方面)都不区分</p>
</li>
<li><p>字符串之间可以+运算连接，**表示重复2遍。</p>
</li>
<li><p>print(,end&#x3D;’’)表示不换行</p>
</li>
<li><p>特殊运算：</p>
</li>
</ol>
<ul>
<li>1.乘方：2**5,2的5次方</li>
<li>2.除法,&#x2F;得到浮点数。&#x2F;&#x2F;得到整数</li>
</ul>
<ol start="6">
<li><p>注释为#，单行和’’’多行’’’</p>
</li>
<li><p>python是动态语言不支持静态变量，可以将变量定义在外部模拟静态变量,不过python既可以面向过程，也可以面向对象。</p>
</li>
<li><p>多元赋值a&#x3D;b&#x3D;1,&#x3D;&#x3D; a&#x3D;1，b&#x3D;1.，在编译过程中，前者会将俩个1压入栈，而后者只有一个会</p>
<blockquote>
<p>tips:值得注意的是:a,b&#x3D;字符串，这个字符串只能两字符，a,b各得一个字符，否则会报错。</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>tips:a&#x3D;b&#x3D;1不等于a,b&#x3D;1。这会报错，必须两个参数赋值，a,b&#x3D;1,1才对</p>
</blockquote>
<ol start="9">
<li><p>true1 or true2 ,true1 and true2。前者返回true1,后者返回true2.因为or只需要判断一次，这个true可以是任何非0和False值。</p>
</li>
<li><p>关键字in str in str2，如果str2包涵str1，那么返回true,反之false</p>
</li>
<li><p>python空值为None,而不是NULL。Null等。</p>
</li>
<li><p>pyhton可以表达式间直接省略and ,比如4&lt;5&gt;3&#x3D;true&#x3D;4&lt;5 and 5&gt;3</p>
</li>
</ol>
<hr>
<h2 id="2-python基础类型"><a href="#2-python基础类型" class="headerlink" title="2.python基础类型"></a>2.python基础类型</h2><ol>
<li>数字类型</li>
</ol>
<ul>
<li><ol>
<li>int(整形)：注意，没有长整型，long,只有int。</li>
</ol>
</li>
<li><ol start="2">
<li>bool(布尔)：比如True</li>
</ol>
</li>
<li><ol start="3">
<li>float(浮点型)：比如1.23</li>
</ol>
</li>
<li><ol start="4">
<li>complex(复数)：比如1+2j</li>
</ol>
</li>
</ul>
<ol start="2">
<li>标准数据类型</li>
</ol>
<ul>
<li><ol>
<li>Numbers（数字）</li>
</ol>
</li>
<li><ol start="2">
<li>String（字符串）</li>
</ol>
</li>
<li><ol start="3">
<li>List（列表）</li>
</ol>
</li>
<li><ol start="4">
<li>Tuple（元组）</li>
</ol>
</li>
<li><ol start="5">
<li>Dictionary（字典）</li>
</ol>
</li>
</ul>
<blockquote>
<p>tips:除开数字以外4种基础类型都基于数组实现。</p>
</blockquote>
<blockquote>
<p>tips2:不可变数据类型：number,String,tuple.可变数据,list,dictionary,set</p>
</blockquote>
<ol start="3">
<li>字符串string</li>
</ol>
<p>tips:注意string虽然是数组，但不可以修改</p>
<p>设str&#x3D;’123456’</p>
<ul>
<li>1.字符串使用：str[se,se]<ul>
<li>1.\str[]一个参数，[0]，[2]分别表示输出第一个和第三个字符</li>
<li>2.[1:3] ,输出第二个到第四个字符</li>
<li>3.[0:-1]输出第一个到最后一个,[0:-2]输出第一个到倒数第二个</li>
<li>4.[1:4:2]以步长为2增长，每隔一个输出一个，比如234，步长2输出为24</li>
<li>5.str<em>2,str**都表示输出2次，*3输出三次，而</em>&#x3D;则是赋值，但字符串不可变，因此列表可用。</li>
</ul>
</li>
</ul>
<blockquote>
<p>tips:str[::-1]表示逆序输出，注意。</p>
</blockquote>
<ul>
<li><p>2.字符串的一些方法</p>
<ul>
<li>1.split(),以参数切开。比如’,’，则每遇到一个，切开。’’则切成一个个字母，注意，<br>使用split返回的是一个列表list</li>
<li>2.str.join() 将str加入到join的参数的那个字符串里面。<br>比如str&#x3D;’12’加入join(‘iab’)，返回为i12a12b。如果不是是列表则列表的每个<br>索引切一个。</li>
<li>3.str.repalce(要被的替换字符，替换的字符)</li>
<li>4.decode(‘’)和encode(‘’),参数为编码，decode为以指定编码解码，encode为以指定编码编码</li>
</ul>
</li>
<li><p>3.字符串格式化：</p>
<ul>
<li>1.str.format():print(‘a&#x3D;{},b&#x3D;{}’.format(‘1’, 2))</li>
</ul>
</li>
</ul>
<ol start="4">
<li>List列表用[],与字符串不同的是列表可以改变，列表的值都可以<br>重新赋值。</li>
</ol>
<p>List方法</p>
<ul>
<li>1.append(在末尾添加对象)</li>
<li>2.pop移除最后一个元素</li>
</ul>
<ol start="5">
<li>Tupel元组()。与列表类似，不过不能修改，不过与字符串一样可以被切片，索引</li>
</ol>
<blockquote>
<p>tips:元组只有一个元素的时候要加逗号比如(x,),不然就是就是原leix,比如(4)类型为int</p>
</blockquote>
<ol start="6">
<li>#4.集合{} 或者 set()</li>
</ol>
<blockquote>
<p>tips注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字。</p>
</blockquote>
<blockquote>
<p>tips2:列表不可以是集合的元素，列表的元素必须是不可变的。比如int和元组</p>
</blockquote>
<p>典。</p>
<ul>
<li>特点为无序，不重复。并且不同集合之间可以使用+-等进行集合运算</li>
</ul>
<ol start="7">
<li>字典 字典是一种映射类型，字典用 { } 标识，它是一个无序的 键(key) : 值(value) 的集合。键(key)必须使用不可变类型。比如{key1:value1,key2:value2}</li>
</ol>
<blockquote>
<p>tips:值得注意的是在同一个字典中，键(key)必须是唯一的，并且key不能是列表</p>
</blockquote>
<blockquote>
<p>tips:字典的添加为[key]&#x3D;value,字典的遍历for (key,value) in 字典名.items()</p>
</blockquote>
<p>注意：字典和集合都是{},{}，get()方法能够通过可以通过key,下标获取value,但不可获取key。get(key,value)则是给key赋此value为默认输出，比如为None则会输出这个默认值，如果不为None则会输出原值。</p>
<p>总结：字符串使用’’,””赋值，列表[]可变,元组()不可变,集合{}可变，值唯一,字典{}可变，键唯一。</p>
<blockquote>
<p>tips:集合和字典在赋值时的值不一样，集合元素为基础类型。字典为key:value</p>
</blockquote>
<blockquote>
<p>tips2:相应转换的内置函数直接为类型(),比如str()</p>
</blockquote>
<blockquote>
<p>tiips:len()用于测量索引长度，type()用于输出类型</p>
</blockquote>
<hr>
<h2 id="3-流程语句"><a href="#3-流程语句" class="headerlink" title="3.流程语句"></a>3.流程语句</h2><ol>
<li><p>if：关键字if,elif,else</p>
</li>
<li><p>循环</p>
</li>
</ol>
<ul>
<li>1.while</li>
<li>2.for 自己命名(variable) in 要循环的序列(sequence)。<blockquote>
<p>tips:in后面的序列可以使用range()函数，生存一个数列。比如range(5)生成一个1~5的数列。<br>range之间用,隔开。上述的标准类型用:隔开，注意区别。同样有开始，结束，步长三种重载。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>tips2:循环后可以根else，结束循环后会执行，但使用break跳出循环后不会执行else.</p>
</blockquote>
<p>注意 数字 for var in se,那么var全部都会变成这个数字，当然你要是放元组也会变成元组。而se中的数也会替换成这个前置值</p>
<ul>
<li><ol start="3">
<li>break结束本次循环，continue,跳出本次循环并且执行下次循环。Python pass是空语句，是为了保持程序结构的完整性。pass 不做任何事情，一般用做占位语句，</li>
</ol>
</li>
</ul>
<ol start="3">
<li><p>迭代器：iter()创建迭代对象，next()输出迭代器的下一个元素。比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list=[1,2,3,4]</span><br><span class="line">it = iter(list)    # 创建迭代器对象</span><br><span class="line">print (next(it))   # 输出迭代器的下一个元素</span><br></pre></td></tr></table></figure>
</li>
<li><p>推导式：for define in 元素集合 if 条件<br>比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name.upper()for name in names if len(name)&gt;3</span><br><span class="line">比如将过滤出(长度大于3)的元素变成大写</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="4-函数"><a href="#4-函数" class="headerlink" title="4.函数"></a>4.函数</h2><ol>
<li><p>定义：def 名字():</p>
<blockquote>
<p>tips:定义不会执行，需要直接使用名字()才会执行</p>
</blockquote>
</li>
<li><p>抽象类和抽象函数，抽象函数定义在抽象对象中，抽象函数@abstractmethod<br>，抽象类需要继承ABC.一般需要from abc import ABC,abstractmethod</p>
</li>
<li><p>函数参数，除开写入的固定参数，还可以给参数赋默认值，比如a(z&#x3D;10),<br>除此此之外，还可以使用变长参数，一个*以元组形式传入。比如a(*z),两个<br>**以字典形式传入。如果单独出现星号 *，则星号 * 后的参数必须用关键字传</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def f(a,b,*,c):</span><br><span class="line">   return a+b+c </span><br><span class="line">f(1,2,3)   # 报错</span><br><span class="line">f(1,2,c=3) # 正常</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tips:关键字就是参数名字&#x3D;参数值的形式传递</p>
</blockquote>
</li>
<li><p>匿名函数：lambada,格式为lambada 参数:表达式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = lambda a : a + 10</span><br><span class="line">print(x(5))</span><br></pre></td></tr></table></figure>
<p>输出值为15</p>
</li>
<li><p>关于静态函数,@staticmethod用于定义静态方法，但静态变量只能采用定义在外面的方法曲线救国。在静态函数中定义没意义，因为如果在里面初始化，那么每次执行该静态变量都会初始化，与类的对象方法无异。</p>
</li>
</ol>
<blockquote>
<p>tips:关于试题：python函数可以分为内置函数和自定义函数</p>
</blockquote>
<hr>
<h2 id="5-模块，包与引入"><a href="#5-模块，包与引入" class="headerlink" title="5.模块，包与引入"></a>5.模块，包与引入</h2><ol>
<li>包即文件夹，必须至少拥有一个.py文件，否则就只是文件夹，而不是包。</li>
<li>模块，即py文件</li>
<li>引入：注意：import引入后会直接执行该模块</li>
</ol>
<ul>
<li>1.import 模块名</li>
<li>2.from 模块名 import 部分：从某个模块引入一部分，如果从某个包的模块引入为from包.模块名</li>
<li>3._<em>name</em>_：每个模块都具有的属性，在本模块运行结果&#x3D;&#x3D;__mian__,被其他模<br>块引入后在其他模块输出为本模块的名字</li>
</ul>
<blockquote>
<p>tips:dir()函数能够返回模块内定义的所有名称。以一个字符串列表的形式返回，注意，可以<br>给参数</p>
</blockquote>
<hr>
<h2 id="6-输入输出"><a href="#6-输入输出" class="headerlink" title="6.输入输出"></a>6.输入输出</h2><ol>
<li>输入input(),返回一个值,参数是提示给输入者的值</li>
<li>文件内容输入：open(filename, mode)</li>
</ol>
<p>filename(文件路径)<br>mode：决定了打开文件的模式：只读，写入，追加等。这个参数是非强制的，默认文件访问模式为只读(r)。</p>
<ol start="3">
<li><p>根据2获取的文件，可以用read()读一个，readline()读一行(\n结束)。readlines()读全部，设置参数可以指定读取的长度。比如open(‘xx’).readline()</p>
</li>
<li><p>写为write(),关闭输入流为close()</p>
</li>
<li><p>移动到某个位置进行读写seek(offset,size)意思是从哪里开始读取多少字节。-1是最后一个。-2为倒二。</p>
</li>
</ol>
<blockquote>
<p>tips:tell()函数返回当前的文件指针指向第几个字节。</p>
</blockquote>
<ol start="6">
<li>序列化：将对象以字符串的形式保存到文件中，再从文件中读取字符串后恢复为对象。</li>
</ol>
<ul>
<li>1.python提供的是pickle,有dump和load方法用来序列化和反序列化(恢复)</li>
<li>2.dump(要序列化的对象,保存地址(open()开打的文件),控制（可不填）)</li>
<li>3.load(flie):从 file(open打开) 中读取一个字符串，并将它重构为原来的python对象。</li>
</ul>
<hr>
<h2 id="7-异常处理"><a href="#7-异常处理" class="headerlink" title="7.异常处理"></a>7.异常处理</h2><ol>
<li><p>关键字为try:..except 错误类型:..</p>
<blockquote>
<p>tips：如果不填错误类型直接except:则无论什么错误都捕获</p>
</blockquote>
</li>
<li><p>可以加else:表示未出错代码，try:..except 错误类型:..else:…</p>
</li>
<li><p>finally：里面的代码一定会执行</p>
</li>
<li><p>raise:用于抛出异常，格式 :raise 错误类型(‘参数’)</p>
</li>
<li><p>自定义异常，自定义异常的类继承(Exception)即可创建异常类，然后可被raise抛出，except接住。</p>
</li>
</ol>
<hr>
<h2 id="8-类"><a href="#8-类" class="headerlink" title="8.类"></a>8.类</h2><ol>
<li><p>定义 class 名字:</p>
</li>
<li><p>引用内部的属性或者方法为名字.引用的名字</p>
</li>
</ol>
<blockquote>
<p>tips:类内部定义的方法都必然有一个参数指向类本身(即第一个)，一般为self,当然叫其他的，只要是第一个参数即可</p>
</blockquote>
<ol start="3">
<li><p>__init_<em>构造方法：__init_</em>(self):,这个方法会在创建类的时候自动调用。</p>
</li>
<li><p>继承，格式为class 名字(要继承的类的名字):</p>
<blockquote>
<p>tips:注意，python支持多继承，可以写多个类的名字</p>
</blockquote>
</li>
<li><p>私有属性与方法：两个下划线声明为私有,比如__a。<br>这边的私有和Java等类似，比如声明私有的属性后，只有使用没有加__的方法返回该值，即只能对象内部调用。</p>
</li>
</ol>
<hr>
<h2 id="9-装饰"><a href="#9-装饰" class="headerlink" title="9.装饰"></a>9.装饰</h2><p>python能够在函数中定义函数，以函数为参数执行函数。<br>而装饰@可以理解为一个函数，用于执行或者在不改变函数本身的情况下修改函数的功能。</p>
<ol>
<li>自己创建一个函数装饰器：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def 自定义函数1(x):</span><br><span class="line">    x()</span><br><span class="line">    def 内部函数:</span><br><span class="line">       print(&#x27;在执行内部函数&#x27;)</span><br><span class="line">    return 内部函数</span><br><span class="line"></span><br><span class="line">@自定义函数1</span><br><span class="line">def 自定义函数2()</span><br><span class="line">    print(&#x27;在执行2&#x27;)</span><br><span class="line"></span><br><span class="line">print(自定义函数2)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>以上代码的执行结果为:在执行2，在执行内部函数</p>
<p>在以上代码中，@创建该函数装饰器，被作为装饰器的函数(函数1)必须要返回一个函数（内部函数），在调用自定义函数2时，会自动执行自定义函数1，并且会执行返回的函数(内部函数)。</p>
<p>并且值得注意的是，自定义函数的一个参数指向被装饰的函数的地址，所以执行这个参数()，等于<br>执行那个函数</p>
<ol start="2">
<li>将类作为装饰器:需要在类内部定义__call__函数，使得类能够像函数一样被调用。</li>
</ol>
<hr>
<h2 id="10-一些特殊的函数和包"><a href="#10-一些特殊的函数和包" class="headerlink" title="10.一些特殊的函数和包"></a>10.一些特殊的函数和包</h2><ol>
<li>random:用于生成随机数(仅介绍一些常用的)</li>
</ol>
<ul>
<li>1.random.ranint(x,y)&#x2F;float(x,y):从x~y之间随机一个整数&#x2F;浮点数，包涵x不包含y。</li>
<li>2.random.random(),随机生成0~1之间的数字。</li>
<li>3.random.choice(sequence,)参数可以为多个序列(比如字典元组等)，从这些参数中随机选取一个返回</li>
<li>4.random.randrange()返回一个随机数集，参数指定范围</li>
</ul>
<ol start="2">
<li>datetime</li>
</ol>
<ul>
<li>1.获取当前的时间datatime.datatime.now._<em>format</em>_(“这里面指定输出格式”)，年月日时分秒为:%Y%m%d%H%M%S,还可以用.today()来获取今天的日期</li>
<li>2.年历月历用calendar.calendar(year)，如果月历则加month</li>
<li>3.是哑巴时间差为datetime包的两个时间相减().days,相差年月改成years,months即可。</li>
</ul>
<ol start="3">
<li>字符测试：</li>
</ol>
<ul>
<li>1.isdigit():检测是否由数字组成</li>
<li>2.isalpha():检测是否由字母和文字组成</li>
<li>3.isalnum():检测是否与由字母数字汉字组成</li>
<li>4.isspace():检测是否只由空白字符组成(注意，包括制表符等，不仅仅是空格)</li>
</ul>
<ol start="4">
<li>正则表达式：</li>
</ol>
<pre><code>import re
re.match(&#39;正则表达式&#39;,要筛选的字符串)，返回值即筛选后的字符
```







</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/29/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%8E%8B%E9%81%93%E5%A4%8D%E4%B9%A0%E6%8C%87%E5%AF%BC/%E8%80%83%E7%A0%94-%E8%AE%A1%E7%BD%91%E5%BA%94%E7%94%A8%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuanSchuan">
      <meta itemprop="description" content="既然选择远方，便不顾风雨亦兼程">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="川山">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/29/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%8E%8B%E9%81%93%E5%A4%8D%E4%B9%A0%E6%8C%87%E5%AF%BC/%E8%80%83%E7%A0%94-%E8%AE%A1%E7%BD%91%E5%BA%94%E7%94%A8%E5%B1%82/" class="post-title-link" itemprop="url">考研-计网应用层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-29 15:25:10" itemprop="dateCreated datePublished" datetime="2022-11-29T15:25:10+08:00">2022-11-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-12 19:57:33" itemprop="dateModified" datetime="2022-12-12T19:57:33+08:00">2022-12-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">计算机网络考研复习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-应用层的网络应用模型"><a href="#1-应用层的网络应用模型" class="headerlink" title="1.应用层的网络应用模型"></a>1.应用层的网络应用模型</h2><ol>
<li>CS客户模型：双方不平等，S可以通过用户授权来管理用户客户机。</li>
<li>P2P点对点模型：双方关系对等。</li>
</ol>
<hr>
<h2 id="2-域名系统-DNS"><a href="#2-域名系统-DNS" class="headerlink" title="2.域名系统(DNS)"></a>2.域名系统(DNS)</h2><ol>
<li><p>概述：作用为将IP解释为比较好记的域名，采用层次树状结构的命名方法。分为顶级域，二级域，三级域等。越高级的域名在越右边，域名间用.隔开。</p>
</li>
<li><p>顶级域名</p>
</li>
</ol>
<ul>
<li>1.国家或地名，比如中国为.cn</li>
<li>2.通用顶级与域名：.com(公司)，.net(网络服务机构)，.org（非营利性组成），.gov(国家或政府部门)。</li>
<li>3.基础结构域名arpa,只有一个，用于反向域名解析。</li>
</ul>
<ol start="3">
<li>域名服务器：</li>
</ol>
<ul>
<li>1.根域名服务器：知道所有顶级域名服务器ip地址。</li>
<li>2.顶级域名服务器：负责在该域名服务器注册的二级域名的ip</li>
<li>3，授权域名服务器(权限域名服务器):每台主机都必须在授权域名服务器处登记，授权服务器总能找到其管辖的主机名转IP地址。</li>
<li>4.本地域名服务器：主要用于缓存域名和缓解上述服务器的查询压力。</li>
</ul>
<ol start="4">
<li>域名解析过程</li>
</ol>
<ul>
<li><p>1.递归查询：向根域名服务器进行DNS查询,根返回顶级域名服务器IP,然后向顶级查，顶级如果没有，就返回权限域名服务器ip,然后向权限查。最后得出IP。</p>
</li>
<li><p>2.迭代查询:即委托本地服务器代替本机进行DNS查询。</p>
</li>
</ul>
<p>注意：递归查询因为会对根域名服务器造成巨大的负担，因此现实中几乎不使用。</p>
<ul>
<li>3.过程<ul>
<li>1.主机向本地DNS服务器查询。</li>
<li>2.本地DNS，先查看本地是否有缓存，如果没有则服务器解析出顶级域名，并向对应的顶级域名服务器查询。</li>
<li>3.顶级域名服务器判断出该域名属于某个授权域名服务器，返回授权域名IP给本地DNS服务器。</li>
<li>4.本地DNS根据IP向授权服务器请求数据，授权服务器返回数据给本地DNS服务器。</li>
<li>5.本地DNS服务器返回给主机。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-传输协议"><a href="#3-传输协议" class="headerlink" title="3.传输协议"></a>3.传输协议</h2><ol>
<li>文件传输协议(FTP):使用TCP连接，服务器打开控制端口21.</li>
</ol>
<ul>
<li>tips:需要两个端口，一个控制端口用来监听请求，传输控制信息。一个数据传输端口，用来传输数据。</li>
</ul>
<ol start="2">
<li>电子邮件(SMPT，POP3,IMAP等)：需要代理人，主机A将邮件发送到代理人，B凑够代理人取邮件。过程如下：</li>
</ol>
<ul>
<li>1.发送人A使用STMP向代理人发送邮件。</li>
<li>2.接收人B使用POP3从代理人拉Pull(取)邮件。</li>
</ul>
<p>注意1：代理人之间发邮件也是使用stmp.</p>
<p>注意2：STMP只能发送简单的ASICC组成的文本，STMP拓展的MIME支持多语言，图像，音频的传输。</p>
<ol start="3">
<li>www万维网</li>
</ol>
<ul>
<li><p>1.组成：1）统一资源定位符+2）超文本传输协议+3）超文本标记语言。</p>
</li>
<li><p>2.特点为:无状态，使用TCP,无状态是指不知道上一次访问者，一般使用本地cookie标识语言。</p>
</li>
</ul>
<p>注意：1.超文本传输协议建立于TCP连接。2.统一资源定位符用于定位给出的路径的资源。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/29/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%8E%8B%E9%81%93%E5%A4%8D%E4%B9%A0%E6%8C%87%E5%AF%BC/%E8%80%83%E7%A0%94-%E8%AE%A1%E7%BD%91%E4%BC%A0%E8%BE%93%E5%B1%82%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuanSchuan">
      <meta itemprop="description" content="既然选择远方，便不顾风雨亦兼程">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="川山">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/29/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%8E%8B%E9%81%93%E5%A4%8D%E4%B9%A0%E6%8C%87%E5%AF%BC/%E8%80%83%E7%A0%94-%E8%AE%A1%E7%BD%91%E4%BC%A0%E8%BE%93%E5%B1%82%E5%A4%8D%E4%B9%A0/" class="post-title-link" itemprop="url">计网-传输层复习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-29 14:36:55" itemprop="dateCreated datePublished" datetime="2022-11-29T14:36:55+08:00">2022-11-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-12 19:59:19" itemprop="dateModified" datetime="2022-12-12T19:59:19+08:00">2022-12-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">计算机网络考研复习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-传输层功能和与网络层的易混淆点"><a href="#1-传输层功能和与网络层的易混淆点" class="headerlink" title="1.传输层功能和与网络层的易混淆点"></a>1.传输层功能和与网络层的易混淆点</h2><ol>
<li>传输层概述：主要为应用层进程之间提供逻辑通信(端对端)，是面向通信的最高层，也是用户功能的最低层。为主机提供端对端的通信服务。</li>
</ol>
<p>值得注意的是，网络层是为主机之间提供通信服务。具体实现区别在于网络使用IP地址，而传输层使用的一种接口，套接字格式:为IP地址,端口号。</p>
<blockquote>
<p>tips:端口，提供储存和缓存服务，同一个应用接收和发送需要不同的端口。换句话说，只有为应用程序指定了端口，应用程序才知道正确的收发数据。</p>
</blockquote>
<ol start="2">
<li>复用和分用：传输层的复用是指不同应用进程可以使用同一个传输层协议(比如tcp),分用指传输层剥去报文首部后能够将这些数据交付到正确的应用程序(端口)中。</li>
</ol>
<p>注意：网络层也有复用和分用。复用指不同协议的数据可以被封装成IP数据报发出，分用指接收方在剥去首部后能够把数据交付给相应的协议。</p>
<ol start="3">
<li>物理层，数据链路层，网络层，传输层对数据错误的处理。</li>
</ol>
<ul>
<li><p>1.物理层进行检错和纠错：主要对于比特，比如传输过程中的信号失真。</p>
</li>
<li><p>2.数据链路层仅仅进行检错，不进行纠错：如果帧数据发送错误直接丢弃。</p>
</li>
<li><p>3.网络层进行纠错和检错：但仅仅针对IP层首部，不对数据部分进行纠错和检错。</p>
</li>
<li><p>4.传输层进行纠错和检错：报错首部和数据部分。</p>
</li>
</ul>
<p>值得注意的是，数据链路层保证的帧不出差错，传输层的纠错主要针对失序，和帧因为错误，拥塞被丢弃而需要重传。</p>
<blockquote>
<p>tips:这样的设计其实主要为了减轻服务器这种集中转发的压力，尽量将数据分开处理。</p>
</blockquote>
<ol start="4">
<li><p>传输层可以同时提供面向连接和无连接。而网络层提供不能同是提供，只能单独提供面向连接服务(虚电路)或者无连接服务(数据报)。</p>
</li>
<li><p>UDP和TCP概述</p>
</li>
</ol>
<ul>
<li><p>1.UDP主要面向无连接，并且尽最大努力交付，不保证数据可靠。主要用于(TFPF（小文件传输协议），DNS,SNMP和RTP(实时传输协议，比如视频))</p>
</li>
<li><p>2.TCP有建立三次握手，断开4次挥手，面向连接，保证数据可靠，主要用于文件传输协议(FTP),超文本传输协议(HTTP)，远程登陆(TELNET)。</p>
</li>
</ul>
<p>注意1：IP数据报和UDP数据报的区别:UDP数据结构对于路由器是不可见的。</p>
<p>注意2：虚电路和TCP数据报的区别：TCP在逻辑层抽象的逻辑信道中传输，对路由器不可见。虚电路所经过的交换结点都必须保存虚电路状态信息，网络层采用虚电路则无法提供无连接服务。但在运输层采用TCP不影响网络层提供无连接服务。</p>
<hr>
<h2 id="2-UDP协议"><a href="#2-UDP协议" class="headerlink" title="2.UDP协议"></a>2.UDP协议</h2><ol>
<li>概述：UDP包装IP数据报仅仅增加了复用，分用和差错检测。因此使用UDP几乎就是和IP数据报打交道。UDP首部为8B(Byte)。</li>
</ol>
<p>注意1：UDP和TCP的分用都是在首部添加端口号来实现的。</p>
<p>注意2：UDP差错检测需时会在首部加上12B的伪首部，只用于校验和临时添加，不会向上递交，也不会向下传递。</p>
<ol start="2">
<li>UDP的一些特点：</li>
</ol>
<ul>
<li><p>1.UDP无需连接，IP无需连接，TCP需要建立连接。</p>
</li>
<li><p>2.UDP无连接状态，TCP需要在主机端维护包括序号，确认号参数等连接状态。</p>
</li>
<li><p>3.UDP分组开销小，首部为8B,TCP为12B。</p>
</li>
<li><p>4.UDP没有拥塞控制能够更好的控制发送时间。</p>
</li>
<li><p>5.UDP可以进行1对1，1对多，多对多。而TCP只能进行1对1.</p>
</li>
</ul>
<hr>
<h2 id="3-TCP"><a href="#3-TCP" class="headerlink" title="3.TCP"></a>3.TCP</h2><p>注意：TCP传送的数据单元为报文段。</p>
<ol>
<li>TCP的特点：</li>
</ol>
<ul>
<li><p>1.TCP面向连接的传输层下协议，连接的是一条逻辑连接。</p>
</li>
<li><p>2.只能进行端对端连接，1对1.</p>
</li>
<li><p>3.提供给无差错服务，即TCP可保证传递给应用层的数据和发送方一致。</p>
</li>
<li><p>4.提供全双工通信。</p>
</li>
<li><ol start="5">
<li>面向字节流，即将数据视为字节组成。</li>
</ol>
</li>
</ul>
<ol start="2">
<li>TCP首部</li>
</ol>
<ul>
<li><p>1.TCP首部长度为固定长度为20B(即最小长度),若需要扩充，必须以4B为单位扩充，即4B的倍数。</p>
</li>
<li><p>2.首部的重点字段介绍</p>
<ul>
<li><p>1.序号4B（seq）:因为TCP是面向字节流的，不是一块数据需要加1，而是计算一块数据中的所有字节数。比如数据发送的第一块为28字节，那么第二块发送的序号则是29开始。</p>
</li>
<li><p>2.数据偏移：指数据部分的开始位数，可以理解为首部长度。</p>
</li>
<li><p>3.确认位ACK,ACK&#x3D;1时数据才有效，&#x3D;0无效。</p>
</li>
<li><p>3.1确认号ack:字母为小写，表示期望对方发送的下一段数据的开始序号。</p>
</li>
</ul>
<p>注意：TCP建立连接后所有报文的ACK为&#x3D;1。</p>
<ul>
<li>4.同步位SYN，当SYN&#x3D;1时，表示这是一个连接请求或者连接接收报文。</li>
</ul>
<p>注意，SYN&#x3D;1,ACK&#x3D;0表明这是一个请求连接报文，如果同意连接，则返回SYN&#x3D;1,ACK&#x3D;1。</p>
<ul>
<li>5.终止位FIN：用于释放连接，当FIN&#x3D;1时，表示此报文段的发送发数据发送完毕，需要要求释放连接。</li>
</ul>
<p>可以理解为发送FIN&#x3D;1的一方传输结束，只会发送通知，不会发送数据，但依旧可以接收数据。</p>
<ul>
<li>6.1）Push推送&#x3D;1，则立刻发送，不必等缓存满。2）RST复位&#x3D;1，TCP出现严重差错(比如主机崩溃)需要重新建立连接。3）窗口：表示允许对方发送的数据量。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>TCP连接建立：</li>
</ol>
<ul>
<li>1.主动方：SYN&#x3D;1,seq&#x3D;x.</li>
<li>2.被动方 ：SYN&#x3D;1,ACK&#x3D;1,seq&#x3D;y,ack&#x3D;x+1</li>
<li>3.主动方:ACK&#x3D;1,seq&#x3D;x+1,ack&#x3D;y+1</li>
</ul>
<p>语言表述：</p>
<ul>
<li>1.主动方请求建立连接(SYN&#x3D;1),填写发送的报文序号x。 </li>
<li>2.被动方同意建立连接(ACK&#x3D;1),SYN&#x3D;1表明是请求报文。填写发送报文序号y,期望收到序号x+1。</li>
<li>3.主动方同意建立连接(ACK&#x3D;1),填写发送报文序号x+1,期望收到y+1</li>
</ul>
<p>值得注意的是：被动方(服务器方)分配资源是在第二次握手时完成的，因此使得服务器易受到SYN洪泛攻击。</p>
<ol start="4">
<li>TCP连接释放(不显示seq和ack)</li>
</ol>
<ul>
<li>1.主动方:FIn&#x3D;1</li>
<li>2.被动方:ACK&#x3D;1</li>
<li>3.被动方:FIN&#x3D;1,ACK&#x3D;1</li>
<li>4.主动方:ACK&#x3D;1</li>
</ul>
<p>语言表述</p>
<ul>
<li>1.主动方FIN&#x3D;1,表示不再发送数据，要求结束连接。</li>
<li>2.被动方ACK&#x3D;1,表示收到要求结束连接请求。</li>
<li>3.被动方如果不再发送数据，则FIN&#x3D;1，发送给主动方。</li>
<li>4.主动方ACK&#x3D;1,表示接收到被动方结束连接的要求。(被动方资源关闭)</li>
</ul>
<p>注意：主动方在发送完结束4后，依旧要等待2MSL(最长报文段寿命)后才会关闭资源(以防该报文被动方没有收到)。</p>
<ol start="5">
<li>TCP连接维护的一些信息：</li>
</ol>
<ul>
<li>1.序号。</li>
<li>2.确认号：在缓存区缓存那些已发出但未收到确认的数据，用于重传。</li>
<li>3.重传，重传的条件有2个。<ul>
<li>1.超时：每发送一个报文段都会给该报文段附加一个计时器，到计时器到时间了，会重发数据报。</li>
<li>2.冗余ACK:如果对方期望的ack大于目前未确认的ack,那么就会重传之间没有确认的ack。</li>
</ul>
</li>
</ul>
<ol start="6">
<li>TCP流量控制：</li>
</ol>
<ul>
<li><p>1.概述：TCP的发送窗口会在对方的接收窗口rwnd(通过首部的接收窗口获取)大小和自己判断的拥塞窗口cwnd(当前网络的拥挤情况)之间取最小值修改为当前的发送窗口。</p>
</li>
<li><p>2.流量控制算法</p>
<ul>
<li>1.慢开始算法：每次发送后拥塞窗口翻倍，比如1，2，4，8…,慢开始算法有设置慢开始门限ssthresh,当达到ssthresh后，就执行用拥塞避免算法。</li>
</ul>
<p>注意1并不一定从1开始，可能2，4，8，16…</p>
<p>注意2：慢开始增长最高为ssthresh,比如阈值为7，那么1，2，4，7之后使用拥塞避免算法，而不是1,2,4,8。</p>
<ul>
<li>2.拥塞避免算法：每次发送后拥塞窗口+1，出现拥塞后(数据报超时)，将拥塞窗口设置为1，重新开始慢开始。</li>
</ul>
</li>
<li><p>3.快重传和快恢复。</p>
<ul>
<li>1.快重传：收到三个冗余ack后直接重传对象未收到的报文段。</li>
<li>2.快恢复,当发送方连续收到3个冗余ACK后，将慢开始的ssthresh设置为此时拥塞窗口的一半，然后将拥塞窗口&#x2F;2(即等于此时慢开始的ssthresh)，然后开始执行拥塞避免算法。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/29/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%8E%8B%E9%81%93%E5%A4%8D%E4%B9%A0%E6%8C%87%E5%AF%BC/%E8%80%83%E7%A0%94-%E8%AE%A1%E7%BD%91%E7%BD%91%E7%BB%9C%E5%B1%82%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuanSchuan">
      <meta itemprop="description" content="既然选择远方，便不顾风雨亦兼程">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="川山">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/29/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%8E%8B%E9%81%93%E5%A4%8D%E4%B9%A0%E6%8C%87%E5%AF%BC/%E8%80%83%E7%A0%94-%E8%AE%A1%E7%BD%91%E7%BD%91%E7%BB%9C%E5%B1%82%E5%A4%8D%E4%B9%A0/" class="post-title-link" itemprop="url">考研-计网网络层复习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-29 09:10:49 / 修改时间：09:14:45" itemprop="dateCreated datePublished" datetime="2022-11-29T09:10:49+08:00">2022-11-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">计算机网络考研复习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-网络层的一些基础知识"><a href="#1-网络层的一些基础知识" class="headerlink" title="1.网络层的一些基础知识"></a>1.网络层的一些基础知识</h2><ol>
<li>中继系统：用于将多个同层网络互联，连接后形成更大的同层。比如交换机与交换机连接是更大的局域网。</li>
</ol>
<ul>
<li><p>1.物理层中继系统：1.转发器。2.集线器。</p>
</li>
<li><p>2.数据链路层中继系统：1.网桥。2.交换机。</p>
</li>
<li><p>3.网络层中继系统：1.路由器。</p>
</li>
<li><p>4.网络层以上中继设备：网关。</p>
</li>
</ul>
<p>注意：历史原因，有些文献将路由器称之为网关。</p>
<ol start="2">
<li>路由器的主要功能：1.路由选择。2.分组转发。</li>
</ol>
<ul>
<li><p>1.路由选择，确定路径，也就是，根据路由协议构造路由表。</p>
</li>
<li><p>2.分组转发：根据路由表衍生出的转发表，选择合适的端口转发数据。</p>
</li>
</ul>
<ol start="3">
<li>网络层可以分为数据层面和控制层面。</li>
</ol>
<ul>
<li><p>1.数据层面：也称转发层面，主要功能为转发。</p>
</li>
<li><p>2.控制层面：主要功能为路由选择。</p>
</li>
</ul>
<ol start="4">
<li>拥塞控制：网络层的拥塞控制为对同行子网进行拥塞控制，主要方法包括开环控制和闭环控制。</li>
</ol>
<ul>
<li><p>1.开环控制：一开始就将拥塞的因素考虑到，中途不再修改，控制手段包括1.何时接收新流量。2.何时丢弃分组。决定时不考虑当前<br>网络状态，因为一开始就准备好了。</p>
</li>
<li><p>2.闭环控制，一开始不考虑拥塞，在运行时用监测网络系统去检测。</p>
</li>
</ul>
<blockquote>
<p>tips:关于拥塞控制和流量控制的区别  </p>
</blockquote>
<p>拥塞控制一般考虑的是全局的一个拥塞情况，根据全局的拥塞情况进行传输控制。<br>流量控制一般考虑的是具体点对点的数据传输，通过抑制发送端的速率使得接收端能够及时接收数据。</p>
<blockquote>
<p>tips2:网络层和传输层均有拥塞控制，网络层的拥塞控制实现介质是路由器，以检测整个网络拓扑拥塞情况的变化。传输层拥塞控制通过具体端，根据数据是否接收，以及接收的时间，次数对网络进行判断，处理拥塞。</p>
</blockquote>
<ol start="5">
<li>错题</li>
</ol>
<ul>
<li>1.路由器连接的异构网络是指：3<ul>
<li>1.网络拓扑结构不同。</li>
<li>2.网络种的计算机操作体系不同。</li>
<li>3.数据链路层和物理层均不同。</li>
</ul>
</li>
</ul>
<p>原因是因为数据链路层和物理层决定网络的物理结构。</p>
<ul>
<li>2.在路由器连接的多个局域网中，要求每个局域网：物理层，数据链路层和网络层协议可以不同，而网络层以上协议必须相同。</li>
</ul>
<p>路由器可以兼容IPv4和IPv6，因此网络协议可以不同。</p>
<ul>
<li>3.路由器的路由器通常包涵：目的地址 掩码 下一条地址</li>
</ul>
<hr>
<h2 id="2-路由算法"><a href="#2-路由算法" class="headerlink" title="2.路由算法"></a>2.路由算法</h2><ol>
<li>路由算法的分类</li>
</ol>
<ul>
<li><p>1.静态路由算法：又称非自适应路由算法，由网络管理员手动配置，当网络拓扑结构发生变化时，由网络管理员手动修改。</p>
</li>
<li><p>2.动态路由算法：又称自适应路由算法。主要通过路由器之间彼此交换信息，然后按照一定优化算法出来，在一定时间间隙内会不断更新，以适应不断变化的网络。</p>
</li>
</ul>
<ol start="2">
<li>路由算法</li>
</ol>
<ul>
<li>1.距离-向量路由算法(RIP算法)：<ul>
<li><p>1.概述：所有结点与邻近结点定期交换整个路由表，并且所有结点都会接听x结点发送的路由表信息，并在发现1)出现新的路由路径。2)发现更短的路径。时更新路由表。</p>
</li>
<li><p>2.在这种算法中，每段距离定义为一跳数，每经过一跳，距离+1.</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>tips:这种算法需要所有结点与邻近结点传递整个路由表，因此在大的网络中通信量会非常大，因此，一般用于小型网络。。</p>
</blockquote>
<ul>
<li>2.链路状态路由算法(OSPF算法):<ul>
<li><p>1.概述：主要特征为每个结点都知道整个网络的拓扑图，进而生成最合适的路由表。会主动测试邻近结点的状态(包括链路状态)，定期的会将链路状态信息传递给所有结点(与RIP不同的时，它传递给邻近结点，邻近结点接收检查后，转发给其他结点，进而传递给整个自治域，但RIP则是直接传给全部整个，而每个结点都会重新发送一次)。</p>
</li>
<li><p>2.链路状态发生变化后使用Dijkstra计算最短路径。</p>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li>层次路由</li>
</ol>
<ul>
<li><p>1.概述：路由器为了减少需要维护的路由表量，需要对路由器再进行划分。将整个互联路划分成许多个较小的自治系统。</p>
</li>
<li><p>2.内部网关协议(IGP):也称域内路由选择，具体协议比如RIP和OSFP等。</p>
</li>
<li><p>2.外部网关协议(EGP):域间路由选择，用于将不同自治系统之间选择最优路径并通信，具体协议比如EGP。</p>
</li>
</ul>
<p>值得注意的是，使用层次路由OSFP会将一个路由系统再划分为若干区域，以减少泛洪带来的巨大通信量。</p>
<p>注意2：每个小的自治系统与外部自治系统连接时，会有专门路由器与外部连接，这些连接外部的路由器又组成了更大的拓扑网络。</p>
<ol start="4">
<li>错题：</li>
</ol>
<ul>
<li><ol>
<li>路由器交付说法错误的是：直接交付时，两台机器可以不再在同一网段内。</li>
</ol>
</li>
</ul>
<p>注意：如果不在同一网段会采用简介交付，而不是直接。</p>
<hr>
<h2 id="3-IPv4"><a href="#3-IPv4" class="headerlink" title="3.IPv4"></a>3.IPv4</h2><p>前情概述：网络层使用的协议为IPv4或者IPv6,二者区别主要在首部固定字段，一些首部功能，最重要的是所能表示的地址后者比前者大的多。</p>
<ol>
<li>组成部分：(仅介绍一些常用和易混淆的)</li>
</ol>
<ul>
<li><p>1.版本：指ip协议版本,ipv4为4.</p>
</li>
<li><p>2.首部长度，总长度，片偏移的基本单位分别为4B,1B,8B</p>
</li>
<li><p>3.标识：每产生一个数据报，就产生一个标识。主要用于分片后，根据相同的标识拼接成一个数据报。</p>
</li>
</ul>
<p>注意：这不是序号，主要用于分片，而IPv6不允许过程中分片(但允许开始时分片)，因此也没有标识字段。</p>
<ul>
<li><p>4.标志MF:MF&#x3D;1表示还有一个分片，0表示没有分片。DF&#x3D;0时才表示允许分片。</p>
</li>
<li><p>5.片偏移：某片相对于原分组的相对位置。</p>
</li>
<li><p>6.协议：不是ip协议，而是上层的传输层协议，用于区分TCP还是UDP。</p>
</li>
</ul>
<ol start="2">
<li>分片：链路层的最大数据量称为最大传送单元(MTU),如果网络层数据报大于MTU那么就需要分片。以下介绍分片的注意点：</li>
</ol>
<ul>
<li><p>1.IPv4首部长度为20,每次分片需要多填充20字节。</p>
</li>
<li><p>2.片偏移的倍数必须是8的倍数，这意味着除开最后一片外，其他分片都是8的倍数。比如50B,那么必须填充至56B。</p>
</li>
<li><p>3.以太网MTU为1500B，广域网一般为576B。</p>
</li>
</ul>
<ol start="3">
<li>IPv4的IP地址</li>
</ol>
<ul>
<li><p>1.IP地址为：网络号+主机号。  共32位，每8位用一个.分隔。<br>为了区分网络号，分为ABCDE类地址。区分为：网络号前1，2，3，4值固定。</p>
<ul>
<li><p>1.A类地址第一位固定为0，后7位随意(不可为全0和全1),因此值为1~126。</p>
</li>
<li><p>2.B类地址第1，2位固定为10，后6位随意，因此值为128~191</p>
</li>
<li><p>3.C类地址为1，2，3固定为110，后5位随意，因此值为192~223</p>
</li>
<li><p>4.D类地址固定为1110，因此值为224~239：此地址为多播地址。</p>
</li>
<li><p>5.E类地址240~255：保留今后使用。</p>
</li>
</ul>
</li>
<li><p>2.特殊IP地址</p>
<ul>
<li>1.网络和主机号全0都表示自己，组合表示本网络的本主机。</li>
<li>2.网络和主机号全1都表示广播地址，组合表示整个广播域的广播地址。注意，路由器可以分隔广播域。</li>
</ul>
</li>
</ul>
<ol start="4">
<li>网络地址转换(NAT)：格式为(全球IP地址：端口)转化成(本地IP地址 ：端口)。主要用于将全球的共有IP地址通过添加端口映射成多个本地IP,用于缓解IPv4地址的耗尽。</li>
</ol>
<p>有意思的是，NAT由于端口其实工作在传输层。</p>
<ol start="5">
<li>子网划分与子网掩码，CIDR</li>
</ol>
<ul>
<li><p>1.子网划分为(&lt;网络号&gt;&lt;子网号&gt;&lt;主机号&gt;)，即从主机号从划分出子网号。</p>
</li>
<li><p>2.CIDR通过子网掩码消除了传统通过网络号来区分不同网段，直接使用掩码对IP地址进行计算。ip地址和掩码进行and运算，即11得1,10得0，00得0。而掩码1与1之间必须为1，比如&#x2F;24掩码，前24位为1，后8位为0.</p>
</li>
<li><p>3.路由聚合：两个ip，取网络号中相同部分的，后面设0。用于路由器的路由跳转。<br>比如192.32.6.9和193.32.7.6可以聚合为192.32.0.0</p>
</li>
</ul>
<p>值得注意的是，对于聚合路由，路由器会优先选择后缀最长的部分转发。比如192.32.0.0和192.32.6.0。会优先转发后者。</p>
<ol start="5">
<li>网络层的转发过程</li>
</ol>
<ul>
<li><p>1.路由表根据(目的网络，下一条地址转跳)。</p>
</li>
<li><p>2.转发优先级：1.特定主机路由。2.聚合路由(越长越先)。3.默认路由。4，报告出错。</p>
</li>
</ul>
<p>值得注意的是：路由器得到下一条路由后，会将IP地址转化成MAC地址并填入帧首部，根据MAC地址找到下一条路由器。</p>
<blockquote>
<p>tips:路由器由于互联多个网络，不仅有多个IP地址，也有多个硬件地址。分别分配在不同的端口。</p>
</blockquote>
<ol start="6">
<li>地址解析协议(ARP):将IP地址转化成MAC地址。工作在网络层。</li>
</ol>
<ul>
<li>1.工作流程：<ul>
<li>1.如果有目标ip地址的mac地址，则直接转化。</li>
<li>2.如果没有目标ip地址的mac地址，则将目标mac地址设置为FF…全一，向网络广播。</li>
<li>3.如果主机A收到APR的广播帧请求，则返回该主机A的MAC地址给ARP。</li>
</ul>
</li>
</ul>
<ol start="7">
<li>动态主机配置协议(DHCP)：基于UDP的应用层协议，主要用于给主机动态分配ip地址。</li>
</ol>
<ul>
<li>1.工作流程<ul>
<li>1.主机广播寻找DHCP服务器。</li>
<li>2.DHCP服务器收到消息后返回动态ip地址给主机。</li>
<li>3.主机如果接受该地址返回确认信息。</li>
<li>4.DHCP正式给主机分配该IP。</li>
</ul>
</li>
</ul>
<ol start="8">
<li>ICMP(网际控制报文协议)：主要用于报告差错或者异常。以ip数据报形式发送。</li>
</ol>
<ul>
<li><p>1.差错报文类型</p>
<ul>
<li><p>1.终点不可达。</p>
</li>
<li><p>2.源点抑制：因为拥塞而丢弃数据报，抑制源点数据发送。</p>
</li>
<li><p>3.时间超过：即ip首部的生存时间达到限定值被丢弃。</p>
</li>
<li><p>4.参数问题：首部字段值不正确。</p>
</li>
<li><p>5.改变路由(重定向):下次发送给更好的路由器，优化路由线路。</p>
</li>
<li><p>2.报告类型为1.路由器询问和通告报文。2.回送请求和回答报文。3.时间戳请求和回答报文。4.地址掩码请求和回答报文。</p>
</li>
</ul>
<blockquote>
<p>tips:ping常常用来测试主机之间的连通性，工作在应用层，直接使用网络层的ICMP。</p>
</blockquote>
<hr>
</li>
</ul>
<h2 id="4-IPv6"><a href="#4-IPv6" class="headerlink" title="4.IPv6"></a>4.IPv6</h2><ol>
<li>注意点(与ipv4的一部分差别)</li>
</ol>
<ul>
<li><p>1.ipv4与ipv6不兼容，路由器无法转发ipv6一般使用隧道技术传输，即将ipv6再包装在ipv4报文中，或者使得路由器同时可以转发ipv6或者ipv4报文，但这种路由器更贵。</p>
</li>
<li><p>2.ipv6地址为128位，ipv4为32位。</p>
</li>
<li><p>3.ipv6首部位数8的倍数，ipv4为4的倍数。</p>
</li>
<li><p>4.ipv6仅仅允许在源主机分片，不允许路由分片，所以一般称ipv6不允许分片。</p>
</li>
</ul>
<ol start="2">
<li>ipv6地址表示</li>
</ol>
<ul>
<li><p>1.ipv6使用:分隔。ipv4使用.分隔。</p>
</li>
<li><p>2.ipv6每16位:分隔一次，且使用16进制数(4位)表示。ipv4每8位分隔一次，且使用8进制数(3位)表示.</p>
</li>
<li><p>3.每一段全0可以用0表示，比如000.1234.000&#x3D;0.1234.0<br>如果多个0连接在一起使用::表示，比如0000.0000.0000.1234&#x3D;::1234,只能使用一次，后面有多个0000也不可以使用::，因为需要其他用位来计算一共省略了几段0。比如上述三段0&#x3D;16*3&#x3D;48，那么剩下为(128-48)&#x2F;16&#x3D;5，即5段，如果有多个::，则无法计算。</p>
</li>
</ul>
<hr>
<h2 id="5-组播"><a href="#5-组播" class="headerlink" title="5.组播"></a>5.组播</h2><ol>
<li>概念：使用UDP协议，并且使用ICMP进行消息控制，发送者只发送一次，在路径不同时复制成两份分开传播，而不用给每个主机单独发送消息。IPv4使用D类地址作为组播地址，ipv6也有专门划分。</li>
</ol>
<p>注意：组播仅保证最大程度交付，不产生差错报文，ICMP主要用于告知路由器需要转发的消息。</p>
<hr>
<h2 id="6-移动IP"><a href="#6-移动IP" class="headerlink" title="6.移动IP"></a>6.移动IP</h2><ol>
<li>三个术语</li>
</ol>
<ul>
<li><ol>
<li>移动结点：即具有永久IP地址的移动结点。</li>
</ol>
</li>
<li><ol start="2">
<li>本地代理：一个移动结点的永久归属网络。</li>
</ol>
</li>
<li><ol start="3">
<li>外部代理：移动IP移动到的外部网络接口。</li>
</ol>
</li>
</ul>
<ol start="2">
<li>通信过程：</li>
</ol>
<ul>
<li>1.移动结点在本地代理是正常转发。</li>
<li>2.移动结点离开本地代理并进入外部代理时，需要向本地代理注册当前位置地址，即转发地址。</li>
<li>3.当本地代理会创建一条通往注册结点的通道，将收到的消息发向外部代理的地址（注册地址）。</li>
<li>4.移动结点发送消息则直接通过外部代理发送消息。</li>
<li>5.回到本地网络时注销。</li>
</ul>
<blockquote>
<p>tips：移动IP为移动主机设计连个IP地址，地址和辅地址(转交地址)。</p>
</blockquote>
<hr>
<h2 id="7-网络层设备"><a href="#7-网络层设备" class="headerlink" title="7.网络层设备"></a>7.网络层设备</h2><ol>
<li><p>冲突域：物理介质上所有结点的集合，这些结点会引发介质争用。链路层设备可以划分冲突域。</p>
</li>
<li><p>广播域：收到同样消息广播消息的结点集合，路由器可以划分广播域。</p>
</li>
<li><p>路由器的组成和功能</p>
</li>
</ol>
<ul>
<li><p>1.直接交付和间接交付：路由器的地址(目标端口地址)如果和主机处于同一网络(即网络号相同，CIDR为掩码掩盖到的位数相同)，则直接交付。处于不同网络，需要查找路由表，则为间接交付。</p>
</li>
<li><p>2.路由器主要功能为构造路由表和分组转发。构造路由表属于路由选择部分，也成为控制部分。分组转发由交换结构，出，入端口组成。</p>
</li>
<li><p>3.路由表格式：目的网络IP,子网掩码,下一条IP地址，接口(即路由器的哪个接口负责转发，因为每个接口对应一个网段。)</p>
</li>
</ul>
<blockquote>
<p>tips注意：路由表总是由软件构造，而转发表可以由软件，也可以由硬件构造。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/21/%E5%89%8D%E7%AB%AF%E8%AF%AD%E8%A8%80/Vue%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuanSchuan">
      <meta itemprop="description" content="既然选择远方，便不顾风雨亦兼程">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="川山">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/21/%E5%89%8D%E7%AB%AF%E8%AF%AD%E8%A8%80/Vue%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/" class="post-title-link" itemprop="url">Vue框架使用说明</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-21 17:07:18" itemprop="dateCreated datePublished" datetime="2022-11-21T17:07:18+08:00">2022-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-18 01:24:46" itemprop="dateModified" datetime="2023-02-18T01:24:46+08:00">2023-02-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">-Vue</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-Vue的安装和卸载"><a href="#1-Vue的安装和卸载" class="headerlink" title="1.Vue的安装和卸载"></a>1.Vue的安装和卸载</h2><p>前置条件:</p>
<ul>
<li>1.npm为node.js自带的包安装工具，如果命令行显示npm不是命令，请安装node.js</li>
<li>2.npm如果不挂vpn建议使用cnpm</li>
<li>3.遇到的坑:使用npm安装依赖时，及时使用管理员权限运行依旧显示权限不足，改用cnpm则可行。原理目前不知。</li>
</ul>
<ol>
<li>使用cmd命令行:</li>
</ol>
<ul>
<li><ol>
<li>安装:npm install -g vue</li>
</ol>
</li>
<li><ol start="2">
<li>卸载:npm uninstall -g vue</li>
</ol>
</li>
</ul>
<hr>
<h1 id="一些常见的注意点："><a href="#一些常见的注意点：" class="headerlink" title="一些常见的注意点："></a>一些常见的注意点：</h1><ul>
<li><p>1.关于bind这类参数的传递:</p>
<ul>
<li>1.如果没有特殊要求，直接填相应名字即可。</li>
<li>2.如果要求对某个属性进行多种赋值或者修改(比如赋予css样式，或者css样式切换)，直接使用数组即可。</li>
<li>3.如果绑定的属性下列还有多个子属性，那么一般使用 { }传递对象，进而能够指定相应的属性修改。</li>
</ul>
</li>
<li><p>2.关于缩写,输入如果直接写routes,会解释成routes:routes; </p>
</li>
<li><p>3.关于依赖的引用可以使用script或者npm安装。</p>
</li>
<li><p>4.v-model等双向绑定是指js的值输出也html页面，而html页面改变这个值后也会改变js界面<br>的这个值。</p>
</li>
<li><p>5.v-model是v-bind:value+v-on，也就是说v-bind:控件的属性&#x3D;””,而v-model不需要<br>写控件的属性，因为默认的是value,并且即使改成控件的其他属性也无效。</p>
</li>
<li><p>6.闭包函数，简单的来讲就是把值和创建时的环境绑定。一般用于js循环绑定事件，因为js循环绑定事件时和事件触发时的i值不同。<br>触发时读取的i值已经变成了最终i值。解决方式就是在外面使用函数包围，将函数的参数作为触发时事件的i值，将循环的i值作为参数。<br>这样，事件触发的值就是当时的绑定的值而不是最终值。</p>
</li>
</ul>
<h2 id="2-目录结构-仅介绍常用目录"><a href="#2-目录结构-仅介绍常用目录" class="headerlink" title="2.目录结构(仅介绍常用目录)"></a>2.目录结构(仅介绍常用目录)</h2><ol>
<li><p>build：该目录下为webpack后生成的代码文件，webpack可以理解为将使用vue生成的效果转化成传统html等文件。</p>
</li>
<li><p>config:配置目录，包括端口号等。</p>
</li>
<li><p>node_modules：npm加载(npm run serve)的模块依赖，即运行时需要的一些下载模块。</p>
</li>
<li><p>src：我们当前开发的目录，可以理解为页面文件和资源文件的存放。还有一些子目录。</p>
</li>
</ol>
<ul>
<li>1.asset：放置图片等资源</li>
<li>2.componts:存放组件(官方建议，可以不用)</li>
<li>3.App.vue：默认的项目入口Vue文件，可以在main.js中修改。</li>
<li>4.main.js：项目的核心文件,用于配置各种文件。</li>
</ul>
<ol start="5">
<li><p>static:静态资源目录</p>
</li>
<li><p>package.json:项目配置文件</p>
</li>
<li><p>README.md:项目说明文档。</p>
</li>
</ol>
<hr>
<h2 id="3-Vue使用概述"><a href="#3-Vue使用概述" class="headerlink" title="3.Vue使用概述"></a>3.Vue使用概述</h2><ol>
<li>vue本质上是将script创建声明数据，然后将数据绑定到html中的元素中，因此衍生出以下两种绑定元素的方法。</li>
</ol>
<ul>
<li><p>1.new Vue( { }),创建一个vue实例的方法，参数中的实例 { }中el属性可以将这个实例绑定给某个元素，当然，也可以使用[]绑定给多个元素。<br>比如new Vue( {el:’#app’ }):绑定给id&#x3D;app的元素</p>
</li>
<li><p>2.创建一个js对象，使用Vue.createApp(对象)创建实例Vue实例，然后用mount()绑定给某个元素。比如Vue.createApp( {data() {return {a:1 }  } }).mount(‘#app’)</p>
</li>
</ul>
<blockquote>
<p>tips:值得注意的是，一般将创建的对象赋值给const 变量名,const和var的区别在于，const类型的数据无法再次赋值，强制赋值会报错。</p>
</blockquote>
<p>值得注意的是:每个对象或者vue实例中有些固定的名称属性有特殊只能，此处介绍data,其他后续介绍。data一般用于是用于存放该对象的数据.</p>
<ol start="2">
<li>将一个js对象绑定给某个元素，可以通过v-model,v-bind,以及 {  {  }  }使用绑定给该元素的对象的数据。</li>
</ol>
<ul>
<li>1.v-model和v-bind：<br>这两个区别在于v-model的数据是双向的，即v-model绑定的数据，如果js中改变，那么页面渲染也会改变。如果页面渲染改变，js中的数据也会改变。<br>v-bind的数据是单向的，只有js中数据改变，页面数据渲染才会改变，如果页面数据改变，那么js中数据不会改变。</li>
</ul>
<p>需要注意的是，v-model，v-bind与  {  {  }  }的主要区别是，前者主要用于元素控件上的属性值赋值，而  {  {  }  }主要用于直接在页面数据输出</p>
<ul>
<li><ol start="2">
<li>{  {  }  }可以直接数据绑定到元素中对象的数据。</li>
</ol>
</li>
</ul>
<blockquote>
<p>tips1:  {  {  }  }和v-model一起配合button使用，可以直接改变js中数据。v-model:value&#x3D;”message”, { {message  }  },那么input中输出的值会直接修改 { {  }  }中message输出的值，进而修改页面。</p>
</blockquote>
<blockquote>
<p>tips2:v-bind可以简写为:,因为v-bind主要绑定属性，所有简写为:属性&#x3D;”值”</p>
</blockquote>
<blockquote>
<p>tips3:非常重要的一点就是,无论是v-bind,model还是 { {  }  }，甚至包括后面介绍的v-if等绑定数据都可以使用表达式，比如三元表达式，使用v-bind:class&#x3D; {条件:正确执行?错误执行 }来进行元素样式的切换，也可以使用 {样式1:boolean值，样式2:boolean值 }来决定样式。其中的boolean值一般使用触发事件绑定的函数来改变值。</p>
</blockquote>
<ol start="3">
<li>v-if&#x3D;&#x3D;”Boolean值”,v-else-if,v-else和v-show<br>概述：主要用于决定是否显示该元素。</li>
</ol>
<ul>
<li>1.前者true会直接渲染，false则不会渲染。</li>
<li>2.v-show无论true或者flase都会渲染，只是简单的进行css切换。</li>
</ul>
<ol start="4">
<li>循环语句v-for</li>
</ol>
<ul>
<li>格式1.v-for&#x3D;”元素名字 in 需要迭代的数组名字”</li>
<li>格式2.v-for&#x3D;”(value,key,index) in 数组名字”。<br>前面的value等名字是固定的，因为数组中的元素可以通过名字:”值”来进行赋值，因此key一般为元素的名字。</li>
<li>格式3.v-for “迭代名字 in 数字”:进行数字次数迭代。</li>
</ul>
<hr>
<h2 id="4-强制分割，因为上面顺序写，内容与上面标题关联不大，因此强制分割。"><a href="#4-强制分割，因为上面顺序写，内容与上面标题关联不大，因此强制分割。" class="headerlink" title="4.强制分割，因为上面顺序写，内容与上面标题关联不大，因此强制分割。"></a>4.强制分割，因为上面顺序写，内容与上面标题关联不大，因此强制分割。</h2><ol>
<li><p>methods,Vue实例的特殊属性(实际为实例中的实例):主要用于声明方法。<br>比如new Vue( {<br>  methods: {<br> 方法名:function() { }<br>}<br> })</p>
</li>
<li><p>computed计算属性：与methods主要区别在于computed有缓存，可以使得计算的速度加快。</p>
</li>
<li><p>监听属性：两种方法，一种是在Vue实例外调用Vue的方法进行监听，一种是在Vue实例中的watch属性中赋值。监听的作用为当监听的属性改变时，会调用对应的方法。</p>
</li>
</ol>
<ul>
<li>1.方法:Vue实例.$watch(‘监听的值属性值名’,function(newValue,oldValue) { })。</li>
</ul>
<blockquote>
<p>tips:需要注意的是，属性名为Vue实例里面的属性，function函数的参数也是一些特殊值，比如上面的参数为新值和旧值。</p>
</blockquote>
<ul>
<li>2.属性:在watch中使用，格式为   名字:function() { }。</li>
</ul>
<blockquote>
<p>tips:值得注意的是，名字是需要监听的属性的名字。</p>
</blockquote>
<ol start="4">
<li>事件处理绑定，v-on：将绑定在该元素中的Vue实例中的指定方法绑定在指定元素。<br>格式为v-on:事件名&#x3D;”方法名”。事件名为触发事件的方式，比如click为点击该元素会触发某个方法。可以简写为@:事件名&#x3D;”方法名”</li>
</ol>
<hr>
<h2 id="5-组件：主要作用为使用模板，对模板进行复用。"><a href="#5-组件：主要作用为使用模板，对模板进行复用。" class="headerlink" title="5.组件：主要作用为使用模板，对模板进行复用。"></a>5.组件：主要作用为使用模板，对模板进行复用。</h2><ol>
<li>创建组件的方法同样有两种。</li>
</ol>
<ul>
<li><p>1.Vue实例中的components属性:格式为components {<br>  名字: {template:’<p>组件<p>‘ }<br> }</p>
</li>
<li><p>2.实例中注册组件Vue.components(“名字”, {template:’<p>组件<p>‘ })</p>
</li>
</ul>
<ol start="2">
<li><p>对子组件传值，可以看见template&#x3D;’’为字符串，要将父组件(上面Vue实例)的值传递子组件(template)中的值，需要使用props专门声明需要传递哪些值给组件。<br>格式为(以1创建方法为例):components {<br> props:[‘ a(设a为对象)’]<br> 名字: {template:’<p> {a.text }<p>‘ }<br> }</p>
</li>
<li><p>props还可以对数值进行验证，比如props: {propA:[ String,Number] }验证是否为字符串或者数字。<br>值得注意的是，NULL和undefine可以通过任何形式的验证。</p>
</li>
</ol>
<hr>
<h2 id="6-有一些特殊的钩子函数，比如update-会在被绑定绑定元素更新时调用，此处就不多追述，可在将来依照需求去找。许多功能，比如渲染时间的确定，次数等。"><a href="#6-有一些特殊的钩子函数，比如update-会在被绑定绑定元素更新时调用，此处就不多追述，可在将来依照需求去找。许多功能，比如渲染时间的确定，次数等。" class="headerlink" title="6.有一些特殊的钩子函数，比如update:会在被绑定绑定元素更新时调用，此处就不多追述，可在将来依照需求去找。许多功能，比如渲染时间的确定，次数等。"></a>6.有一些特殊的钩子函数，比如update:会在被绑定绑定元素更新时调用，此处就不多追述，可在将来依照需求去找。许多功能，比如渲染时间的确定，次数等。</h2><hr>
<h2 id="7-路由"><a href="#7-路由" class="headerlink" title="7.路由"></a>7.路由</h2><ol>
<li><p>概述：同样，可以在Vue实例中创建一个routes对象用于该对象绑定元素的路由。<br>路由主要用于渲染局部页面，而不是像传统的A标签直接整个页面渲染。</p>
</li>
<li><p>路由注册：创建对象const routes&#x3D;[ { path:’路径，一般相较于当前层次的相对路径’,component:组件名称  }, {第二个路由对象 }]。下面直接在元素中注册即可。</p>
</li>
<li><p>路由使用，在将拥有路由的Vue实例挂在相应元素中后，才可以使用。</p>
</li>
</ol>
<ul>
<li>1.触发格式&lt; router-link to&#x3D;’这个路径选自上面在Vue实例中注册的路径’&gt;&lt;&#x2F; router-link&gt;</li>
</ul>
<blockquote>
<p>值得注意的是，router-link可以简单的视为&lt; p&gt;这样的标签元素，可以设置样式，中间的元素直接显示等。</p>
</blockquote>
<ul>
<li>2.触发后显示的组件:&lt; router-view&gt;&lt;&#x2F; router-view&gt;</li>
</ul>
<p>解释：router-link是触发点(跳转点)，router-view用于显示触发后的内容。</p>
<blockquote>
<p>tips:有意思的是,bind:to可以使得跳转的地址更改，即bind和路由的配合。</p>
</blockquote>
<hr>
<h2 id="8-Vue具有自带过渡动画，比如-lt-transition-name-x3D-’fade’-gt-标签包裹的元素消失出现会淡入淡出，具体过渡效果按需求找，这里不多做赘述。"><a href="#8-Vue具有自带过渡动画，比如-lt-transition-name-x3D-’fade’-gt-标签包裹的元素消失出现会淡入淡出，具体过渡效果按需求找，这里不多做赘述。" class="headerlink" title="8.Vue具有自带过渡动画，比如&lt; transition name&#x3D;’fade’&gt;标签包裹的元素消失出现会淡入淡出，具体过渡效果按需求找，这里不多做赘述。"></a>8.Vue具有自带过渡动画，比如&lt; transition name&#x3D;’fade’&gt;标签包裹的元素消失出现会淡入淡出，具体过渡效果按需求找，这里不多做赘述。</h2><hr>
<h2 id="9-Vue与ajks请求"><a href="#9-Vue与ajks请求" class="headerlink" title="9.Vue与ajks请求"></a>9.Vue与ajks请求</h2><ol>
<li><p>前述：ajks,封装有前端与后端交互的方法。<br>不过ajks方法过于繁杂，因此使用axios(基于akjs封装有前后端的访问方法。)，注意，使用这个需要npm安装axios.</p>
</li>
<li><p>get传递和读取数据<br>axios<br>   .get(‘请求的目标路径’)<br>   .then(response &#x3D;&gt; (this.info &#x3D; response))<br>   .catch(function (error)  { &#x2F;&#x2F; 请求失败处理<br> console.log(error);<br>});</p>
</li>
</ol>
<blockquote>
<p>tips1:.then中的为箭头函数，格式为参数&#x3D;&gt;(),(中的值自动返回)，而上面的response是上面请求返回的数据</p>
</blockquote>
<ul>
<li><p>1.注意，要获取json数据，为response.data</p>
</li>
<li><p>2.get传递数据为在目标路径后?key&#x3D;value&amp;&amp;key2&#x3D;value2…</p>
</li>
<li><p>3.若不需要传递参数则直接请求即可。</p>
</li>
</ul>
<p>总结：传递数据在路径后加?,获取数据直接请求地址即可。</p>
<ol start="3">
<li>post传递和获取数据<br>axios.post(‘&#x2F;user’,  {<br> firstName: ‘Fred’,        &#x2F;&#x2F; 参数 firstName<br> lastName: ‘Flintstone’    &#x2F;&#x2F; 参数 lastName<br>})<br>  .then(function (response)  {<br> console.log(response);<br>})<br>  .catch(function (error)  {<br> console.log(error);<br>});</li>
</ol>
<p>  注意。post与get区别在于get参数直接在请求头，而post则会隐藏参数。</p>
<ol start="4">
<li><p>axios执行多个并发请求：<br> axios.all([getUserAccount(), getUserPermissions()])<br>  .then(axios.spread(function (acct, perms)  {<br>&#x2F;&#x2F; 两个请求现在都执行完成<br>   }));</p>
</li>
<li><p>可以通过创建axios实例来复用，比如以下get获取图片流<br>  &#x2F;&#x2F;  GET 请求远程图片<br>axios( {<br>  method:’get’,<br>  url:’目标地址’,<br>  responseType:’stream’<br> })<br>  .then(function(response)  {<br>  response.data.pipe(fs.createWriteStream(‘ada_lovelace.jpg’))<br> });</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/15/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%8E%8B%E9%81%93%E5%A4%8D%E4%B9%A0%E6%8C%87%E5%AF%BC/%E8%80%83%E7%A0%94-%E8%AE%A1%E7%BD%91%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuanSchuan">
      <meta itemprop="description" content="既然选择远方，便不顾风雨亦兼程">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="川山">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/15/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%8E%8B%E9%81%93%E5%A4%8D%E4%B9%A0%E6%8C%87%E5%AF%BC/%E8%80%83%E7%A0%94-%E8%AE%A1%E7%BD%91%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/" class="post-title-link" itemprop="url">考研-计网数据链路层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-15 14:51:52 / 修改时间：14:52:23" itemprop="dateCreated datePublished" datetime="2022-11-15T14:51:52+08:00">2022-11-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">计算机网络考研复习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-数据链路层的功能"><a href="#1-数据链路层的功能" class="headerlink" title="1.数据链路层的功能"></a>1.数据链路层的功能</h2><ol>
<li><p>主要作用:加强物理层的传输原始比特流的功能，将物理层可能出错的物理连接改造成逻辑上无差错的数据链路。</p>
</li>
<li><p>为网络层提供的以下服务：</p>
</li>
</ol>
<ul>
<li>1.无确认的无连接服务。</li>
<li>2.有确认的无连接服务:即不需要预先建立连接，但每次受到的帧都需要确认，一般用于误码率较高的通信，比如无线通信。</li>
<li>3.有确认的面向连接服务。<blockquote>
<p>tips:有连接就一定要有确认，不确认的面向连接无意义。</p>
</blockquote>
</li>
</ul>
<ol start="3">
<li><p>链路管理:数据链路层连接的建立，维持和释放过程称为链路管理，主要用于面向连接服务。</p>
</li>
<li><p>帧定界，帧同步，透明传输。</p>
</li>
</ol>
<ul>
<li>1.帧定界：确定每一帧的界限。比如HDLC以F作为帧的界限。</li>
<li>2.帧同步:从二进制比特流中区分帧的起始与终止。</li>
<li>3.透明传输：指传输过程中，特殊符号(比如帧定界)符号不对传输造成影响。</li>
</ul>
<ol start="5">
<li><p>流量控制:限制发送方的数据流量，使得接收方不会因为来不及接收而丢弃帧。</p>
<blockquote>
<p>tips：数据链路层控制的是两个相邻结点间数据链路上的流量，对于运输层来说，控制的是源端到目的端之间的流量。</p>
</blockquote>
</li>
<li><p>差错控制:确认接收方是否正确收到发送方的数据的方法。这些差错可以分为</p>
</li>
</ol>
<ul>
<li>1.位错:指帧中某些位出现差错，一般使用循环冗余校验(CRC)，通过自动重发请求(ARQ)方式传输出错的帧。<blockquote>
<p>tips:值得注意的是，接收方会直接丢弃出错的帧，而发送发则会发从超时的帧。</p>
</blockquote>
</li>
<li>2.帧错:帧丢失，重复，失序。引入定时器和编号机制，保证每一帧最终能够仅有一次到达目的地。</li>
</ul>
<hr>
<h2 id="2-组帧"><a href="#2-组帧" class="headerlink" title="2.组帧"></a>2.组帧</h2><ol>
<li><p>组帧:将比特流封装成帧进行单位传输，包括帧定界，帧同步，透明传输。</p>
</li>
<li><p>帧定界</p>
</li>
</ol>
<ul>
<li>1.字符计数法:在帧头部表明帧内的字符数。</li>
<li>2.字符填充的首尾定界符:即使用特殊字符标明首尾，如果文本内包涵特殊字符，需要使用转义字符表明非帧定界符。</li>
<li>3.零比特填充首尾标志:对于帧定界符比如F11111111作为帧定界，发送方直接在非帧定界的数据文本中添加0，用于表示帧定界，在接收方解析时每这么一个组合删去一个0用以恢复文本。</li>
<li>4.违规编码法:在物理层进行比特编码时，采用违规编码法进行帧定界，比如曼切斯特的高高电平。</li>
</ul>
<ol start="3">
<li>位差错控制：利用编码技术进行差错控制为ARQ(自动重传)和FEC(向前纠错)。<blockquote>
<p>tips：在FEC纠错中，可以发现差错，并进行纠错。因此差错控制分为检错编码和纠错编码。</p>
</blockquote>
</li>
</ol>
<ul>
<li><p>1.奇偶校验码:奇偶校验码是奇校验码和偶校验码的统称，如果是奇校验码，会在末尾加上一个校验元元”1”，表示奇数个1，如果原本就奇数1，则加0。它只能检测奇位数是否出错，不能检测哪里出错，也不能检测偶数是否出错。</p>
</li>
<li><ol start="2">
<li>循环冗余码(CRD):又称多项式码，发送和接收双方会事先约定一个多项式，发送方会对将发送的数据与约定的多项式进行模2除法运算，得出的余数放在原本的数据后面一同发送，接收方用接收到的数据除以多项式，如果余数为0，则无差错。</li>
</ol>
</li>
</ul>
<blockquote>
<p>tips1：多项式例子:x^3+x^1&#x3D;1010</p>
</blockquote>
<blockquote>
<p>tips2:模2运算，加法不进位，减法不借位。</p>
</blockquote>
<blockquote>
<p>tips3:值得注意的是，发送方的被除数(发送的数据)根据多项式的最大值补0，比如x^3那么需要在后面补三个0.<br>并且模2运算是1是0，根据最高位是否相同，比如101除以100&#x3D;1…001,010除以100&#x3D;0…10</p>
</blockquote>
<p>值得注意的是:循环冗余码能够进行检错，纠错，数据链路层只使用循环冗余码的检错功能，对于错误的帧直接丢弃，不进行检错。</p>
<ul>
<li><p>3.纠错编码:通过加入冗余码，能够推导出接收方实际发送的数据，著名的为海明码。<br>海明码规则：</p>
<ul>
<li>海明码每个海明码的位置规则为，第n个海明码&#x3D;2^n-1，比如2^(1-1)&#x3D;1,2^(2-1)&#x3D;2,2^(3-1)&#x3D;4。</li>
<li>数据位:错落在海明码之间，比如2,4之间的3。为数据位。</li>
<li>海明码的值确定:海明码的值会根据数据长度进行确定。</li>
</ul>
<ol>
<li>比如加海明码&#x3D;5位，那么数据位为3,5。</li>
<li>根据数据位与海明码位的加法关系与海明码有关系的值:3&#x3D;2+1，5&#x3D;3+2.</li>
<li>然后选取和海明码有关系数据进行异或运算:比如第1位海明码为3数据位，第二位海明码为:第三位数据和第五位数据进行异或运算。</li>
<li>最后将海明码和与海明码有关系(即2的加法关系)的数据进行异或运算，每一位海明码进行都进行，如果为0则无错，1为出错。</li>
</ol>
<blockquote>
<p>tips:异或运算为相同为1，不同为0</p>
</blockquote>
<hr>
</li>
</ul>
<h2 id="3-流量控制与可靠传输机制"><a href="#3-流量控制与可靠传输机制" class="headerlink" title="3.流量控制与可靠传输机制"></a>3.流量控制与可靠传输机制</h2><p>注意1：因为数据链路层会重传，因此以下的传输方式都有缓冲区，只不过因为发送的数据最大大小有区别因而缓冲区大小也不同。<br>注意2：因为除开停止等待协议(因为这个协议每次只发送一帧)以外均需要序号表示。<br>后退N帧为有序，选择重传为无序。</p>
<ol>
<li><p>滑动窗口:即限定一个窗口进行发送和接收，发送完往后靠。<br>从滑动窗口看，1.停止-等待流量控制(收发窗口的帧数为1)。2.后退N帧协议(GBN，,设序列号为n位,发送窗口1&lt;&#x3D;N&lt;&#x3D;(2^n)-1，接收窗口为2^n),3.选择重传协议(SR,设序列号为n位,发送和接收窗口为2^(n-1))。只有滑动窗口大小的区别。</p>
</li>
<li><p>停止-等待协议:接收方和发送方均为一个窗口(即一帧)，每发送一帧，需要等待接收方发回一个确认帧才发送下一帧，效率很低。</p>
</li>
<li><p>后退N帧:一次多送多个帧，不必每一帧都发送确认帧ACK，可以在收到此次多帧的最后一帧发送确认帧。如果某一帧出错，则将这一批帧全部重发，因此对于通信质量不太好的信道后退N帧的效率不一定比停止等待协议效率高。</p>
</li>
<li><p>选择重传协议(SR)：一次也发送多帧，但接收方会发送出错的制定帧重传，而不必重传全部。</p>
</li>
</ol>
<blockquote>
<p>tips：值得注意</p>
</blockquote>
<ol start="5">
<li>错题</li>
</ol>
<ul>
<li>1.后退N帧协议，发送窗口大小为32，需要 (6) 位序列号才能保证不出错。接收窗口为32+1&#x3D;33，需要2^6&#x3D;64才能。</li>
</ul>
<p>值得注意的是:设序列号为n，发送窗口为(2^n)-1，而接收窗口的大小为2^n，接收窗口&#x3D;发送窗口+1</p>
<ul>
<li>2.选择重传采用5帧序列号，最大接收窗口为16。</li>
</ul>
<p>即2^(5-1)&#x3D;16</p>
<ol start="6">
<li>补充</li>
</ol>
<ul>
<li><p>1.信道利用率，发送速率，数据帧大小，窗口大小，单向传播时延在这里的关系。</p>
</li>
<li><p>2.信道利用率100%是指忽略传播时延，即每时每刻都有数据在链路上。求信道利用率&#x3D;传播时延&#x2F;(传播时延+单向传输时延),如果有确认帧则信道利用率&#x3D;传播时延&#x2F;(传播时延*2+单向传输时延*2)</p>
</li>
<li><p>3.数据帧大小*窗口大小得出的是当前发送数据的传播时延</p>
</li>
</ul>
<hr>
<h2 id="4-介质访问控制"><a href="#4-介质访问控制" class="headerlink" title="4.介质访问控制"></a>4.介质访问控制</h2><ol>
<li>作用:使用介质隔离同一信道上其他结点所传送的信号。主要决定广播信道中信道分配，该协议属于数据链路层的一个子层，称为介质访问控制层。</li>
</ol>
<blockquote>
<p>tips：广播信道不是指在空气中传播的广播技术，而是向一个局域网内多个结点发送一条数据。</p>
</blockquote>
<ol start="2">
<li><p>信道访问控制分为:1.信道划分介质访问控制。2.随机访问介质访问控制。3.轮询访问介质访问控制。1为静态划分信道方法，2，3后者为动态分配信道的方法。</p>
</li>
<li><p>信道划分介质访问控制:</p>
</li>
</ol>
<ul>
<li>1.频分复用(FDM)：即将多路基带信号调制到不同频率载波上。</li>
<li>2.时分多路复用(TDM):将一条信道轮流给多个信号使用，每个信号使用时间一样。</li>
<li>3.统计时分多路复用(STDM,异步时分多路复用):将一条信道轮流给多个信号使用，每个信号按需求分配时间。</li>
<li>4.波分多路复用(WDM):光的频分多路复用。</li>
<li>5.码分多路复用(CDM):采用不同编码区分原始信号，既共享频率，又共享时间。<br>每个站点有专属的码片，反码为0。同一个信道中传输的码片内积要为0.分离则将内积码片相加*要分离的码片的码(内积)*(1&#x2F;m),其中m为码片的比特个数。</li>
</ul>
<blockquote>
<p>tips：变量内积例子a(1,0).b(0,1)内积&#x3D;1*0+0*1&#x3D;0</p>
</blockquote>
<ol start="4">
<li>随机访问介质访问控制:又称争用型协议，主要为了减少碰撞域内碰撞概率。</li>
</ol>
<ul>
<li>1.ALOHA:直接发送数据，若发生碰撞，则让各个发送发随机等待一段时间再发送。</li>
<li>2.时隙ALOHA：将各站时间统一，划分为时隙，规定只能在每个时隙开始时才能发送帧。(效率是ALOHA效率的两倍)</li>
<li>3.CSMA(Carrier Sense Multiple Access)：ALOHA的改进，改进为增加了载波监听装置，用于监听信道是否忙。<ul>
<li>1.坚持-CSMA:要发送数据时，一直监听信道，如果忙则不发送，如果不忙则直接发送。</li>
<li>2.非坚持-CSMA：不会一直监听，发送数据时监听到忙则等待一个随机时间再监听。</li>
<li>3.p-坚持CSMA：一直监听，如果信道空闲，则以概率p发送数据，以1-p推迟到下一个时隙。</li>
</ul>
</li>
</ul>
<ol start="5">
<li>CSMA&#x2F;CD协议</li>
</ol>
<ul>
<li><p>1.概念:CSMA的改进，改进点检测到信道空闲时，为能够边发送边监听，一旦检测到数据碰撞，则停止发送(会发送一个拥塞信号让其他结点知道)并随机重发。</p>
</li>
<li><p>2.碰撞窗口:碰撞窗口&#x3D;2倍传输时延</p>
</li>
<li><p>3.碰撞检测:如果需要检测到碰撞，那么需要传播(发送)时延至少大等于两倍的传输时延，求最小帧长。最小帧长&#x3D;总线传播时延*2*数据传输速率,即穿过碰撞窗口的时间内发送的数据大小，要大等于这个数才能碰撞。</p>
</li>
<li><p>4.2进制退避算法:每碰撞一次，随机发送的选择时间增加。设碰撞i次，第i次在0~(2^i)-1之间选择时间。</p>
</li>
</ul>
<blockquote>
<p>tips:采用CSDM&#x2F;CD的协议只能进行半全工通信。</p>
</blockquote>
<ol start="6">
<li><p>CSMA&#x2F;CA协议:CSMA&#x2F;CD变体，主要用于无线通信，检测碰撞域成本很高，因此不检测碰撞域。</p>
</li>
<li><p>轮询访问:令牌传递协议:用户不能随意发送数据，需要控制站以循环方式询问每个结点，再决定信道分配。当有结点通信时，其他结点不能通信。结束释放令牌。</p>
</li>
</ol>
<hr>
<h2 id="5-局域网"><a href="#5-局域网" class="headerlink" title="5.局域网"></a>5.局域网</h2><ol>
<li>局域网的三个要素:1.拓扑结构。2.传输介质。3.介质访问控制方式。</li>
<li>常见局域网拓扑结构:1.星形结构。2.环形结构。3.总线结构。4.星星和总线复合结构。</li>
<li>特殊局域网拓扑实现:</li>
</ol>
<ul>
<li>1.以太网:逻辑拓扑为环形结构，物理拓扑为星形或拓展星形结构。</li>
<li>2.令牌环:逻辑拓扑为环形结构,物理拓扑为星型结构。</li>
</ul>
<ol start="4">
<li>数据链路层的两个子层:1.逻辑链路控制(LLC)和媒体介入控制(MAC)。LLC主要用于为网络层提供服务，包括确认无连接等。MAC作用为组帧，透明传输等。</li>
</ol>
<p>值得注意的是，因为以太网几乎称为局域网的代名词，很多网卡仅装有MAC协议而没有LLC协议。</p>
<ol start="5">
<li>MAC帧格式:1.目的地址(6位)。2.源地址(6位)。3.类型(2位,即协议类型)。4.数据(46~1500)。5.FCS(4位,检错码)。</li>
</ol>
<p>tips:MAC帧的首部和尾部为18位，最短帧为64,因此数据字段最短为46。最大1500为规定。</p>
<ol start="6">
<li><p>以太网的传输介质:T表示双绞线，F表示光纤。</p>
</li>
<li><p>无线局域网:分为有固定基础设施局域网(比如wife，核心为接入点AP(Acsess Point))和无固定基础设施的移动自组织网络。</p>
</li>
</ol>
<ul>
<li><p>1.有固定基础设施最小构建是基本服务集BSS(Basic Service Set),核心</p>
</li>
<li><p>2.经过AP的数据帧:A(结点)-&gt;AP-&gt;B(结点).<br>AP帧地址:AP,A,B<br>B帧地址:B,AP,A<br>即目的地址，发送地址，目的源地址<br>和目的地址，发送地址，发送源地址</p>
</li>
</ul>
<ol start="8">
<li>VLAN虚拟局域网:即缩小广播域。</li>
</ol>
<ul>
<li>1.不同交换机传递VLAN的消息，交换机会根据是否属于本VLAN选择转发或丢弃。同交换机不同VLAN发送需要借助上层路由器或者嵌入专用芯片。</li>
</ul>
<hr>
<h2 id="6-广域网"><a href="#6-广域网" class="headerlink" title="6.广域网"></a>6.广域网</h2><ol>
<li><p>广域网虽然由结点交换机进行分组转发，但结点交换机不是路由器。广域网横跨物理层，数据链路层，网络层。而局域网仅仅再数据链路层和网络层。</p>
</li>
<li><p>PPP协议:点对点通信的串行线路，传输字节的协议。</p>
</li>
</ol>
<ul>
<li><p>1.建立在SLIP上，SLIP仅能传输传输IP分组，且没有寻址，数据检查的功能。</p>
</li>
<li><p>2.组成部分:</p>
<ul>
<li>1.链路控制协议(LCP):用于建立，配置，测试，管理数据链路。</li>
<li>2.网络控制协议(NCP):为多种网络协议建立和配置逻辑连接。</li>
<li>3.一个将IP数据报封装到串行链路的方法。</li>
</ul>
</li>
<li><p>3.格式:</p>
<ul>
<li>1.F(1)+A(1)+C(1)+协议(2)+信息部分(1500&lt;)+FCS(2)+F(1)<br>F是标志字段(7E),A地址，C控制字段</li>
</ul>
</li>
</ul>
<blockquote>
<p>tipds1:PPP提供检错，但不纠错。只保证无差错接收(硬件CRC校验)</p>
</blockquote>
<blockquote>
<p>tips2:仅支持点对点链路通信，不支持多点线路。</p>
</blockquote>
<blockquote>
<p>tips3:PPP只支持全双工链路，这意味不需要使用CSDM&#x2F;CD，也就没有最短帧。</p>
</blockquote>
<ol start="4">
<li>HDLC协议:面向比特的数据链路层协议。</li>
</ol>
<ul>
<li>HDLC和PPP最大的区别在于PPP面向字节，而HDLC面向比特。</li>
</ul>
<hr>
<h2 id="7-数据链路层设备"><a href="#7-数据链路层设备" class="headerlink" title="7.数据链路层设备"></a>7.数据链路层设备</h2><ol>
<li><p>网桥:用以扩大以太网。原来的以太网被称为大以太网的一个网段。</p>
</li>
<li><p>交换机:本质上是一个多端口的网桥。能够更方便的实现虚拟局域网VLAN。</p>
</li>
</ol>
<ul>
<li>1.网桥和交换机区别:交换机能够缩小冲突域，而网桥不行。</li>
<li>2.网桥和交换机都无法缩小广播域，不过交换机能够方便的建立虚拟局域网缩小广播域，也能够隔离冲突域。</li>
</ul>
<ol start="3">
<li>交换机的自学习功能:A(主机)向B(主机)发送数据，交换机会记录A的地址，并向除A以外的该局域网广播寻找B(如果交换表有B则直接发送不广播)。其他主机会因为不是自己的地址丢弃该帧，B会收下，如果向A返回信息，那么交换机也会记录B的地址。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/15/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%8E%8B%E9%81%93%E5%A4%8D%E4%B9%A0%E6%8C%87%E5%AF%BC/%E8%80%83%E7%A0%94-%E8%AE%A1%E7%BD%91%E7%89%A9%E7%90%86%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuanSchuan">
      <meta itemprop="description" content="既然选择远方，便不顾风雨亦兼程">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="川山">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/15/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%8E%8B%E9%81%93%E5%A4%8D%E4%B9%A0%E6%8C%87%E5%AF%BC/%E8%80%83%E7%A0%94-%E8%AE%A1%E7%BD%91%E7%89%A9%E7%90%86%E5%B1%82/" class="post-title-link" itemprop="url">考研-计网物理层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-15 14:49:24 / 修改时间：14:51:14" itemprop="dateCreated datePublished" datetime="2022-11-15T14:49:24+08:00">2022-11-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">计算机网络考研复习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1.基础概念"></a>1.基础概念</h2><ol>
<li><p>物理层的作用：物理层不是材料，可以理解为第0层，主要用于屏蔽材料带来的影响进而透明的传输比特流。</p>
</li>
<li><p>模拟信号和数字信号</p>
</li>
</ol>
<ul>
<li>1.模拟信号：连续变化的数据或者信号。</li>
<li>2.数字信号：取值仅允许为有限的几个离散数值的数据。</li>
</ul>
<ol start="3">
<li><p>码元：固定时常的信号波形(数字脉冲)表示一位k进制的数字，用于代表不同离散数值的基本波形，是数字通信中的计量单位。</p>
<blockquote>
<p>tips:1.码元用于数字信号，代表k进制数.</p>
</blockquote>
</li>
<li><p>数据通信系统的主要三个划分:信源，信道和信宿。</p>
</li>
</ol>
<ul>
<li>1.信源:发送端。</li>
<li>2.信道；传输信号(信源的信号需要经过转换在信道上传输)。</li>
<li>3.信宿:接收端</li>
</ul>
<blockquote>
<p>tips:数据通信指数字计算机和其他数字计算机终端之间的通信。</p>
</blockquote>
<blockquote>
<p>tips2:信道与电路并不等同，信道是信号的传输媒介，可以视为一条线路上的逻辑部件，一般用来表示某个方向传送信息的介质。而一条通信线路(电路)往往包涵一条发送信道和接收信道。</p>
</blockquote>
<ol start="5">
<li><p>按照传输介质可以划分为:1.无线信道和2.有线信道</p>
</li>
<li><p>信道上传送的信号有基带信号和宽带信号之分。</p>
</li>
</ol>
<ul>
<li>1.基带信号:2进制的数字信号，码元为1和0.在数字信道上传输，称为基带传输。</li>
<li>2.宽带信号:将基带信号进行调制后形成频分复用模拟信号，然后在模拟信道上传输。<blockquote>
<p>tips1:基带信号为数字信号，宽带信号为模拟信号。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>tips2:基带信号为二进制的数字信号，宽带信号的模拟信号没有规定。</p>
</blockquote>
<ol start="7">
<li>通信双方的交互方式分为三种方式：</li>
</ol>
<ul>
<li>1.单向通信：A只能发送，B只能接收。</li>
<li>2.半双工通信:A,B均能发送和接收，但当A发送时，B只能接收。</li>
<li>3.全双工通信:A,B可以同时发送和接收信息，也就是需要两条通道。<blockquote>
<p>tips:信息的极限容量是指信道的最高码元传输速率或信道的极限信息传输速率。</p>
</blockquote>
</li>
</ul>
<ol start="8">
<li>速率，波特和带宽：</li>
</ol>
<ul>
<li>1.速率:即数据率，也称数据传输速率，表示单位时间内传输的数据量。可以用码元传输速率和信息传输速率表示。</li>
<li>2.码元传输速率：即波特率，表示单位时间内数字通信系统所传输的码元个数(也可称为脉冲个数或者信号变化的次数)。单位是波特，1波特表示数字通信系统每秒传输一个码元。<br>值得注意的是，码元速率与进制数无关。</li>
<li>3.信息传输速率:又称信息速率，比特率等。表达表示单位时间内数字通信系统传输的二进制码元个数(即比特数),可以理解为传输一个1或者0,即bit&#x2F;s</li>
</ul>
<blockquote>
<p>tips:码元传输速率也称调制速率，波形速率和符号速率，若一个码元携带n比特的信息量，则码元M*码元传输速率&#x3D;信息传输速率</p>
</blockquote>
<ul>
<li>4.带宽原指信号的频带宽度，单位为Hz,但在计算机网络中表示最高数据率时表示最大数据通信率，单位为b&#x2F;s</li>
</ul>
<hr>
<h2 id="2-奈奎斯特定理与香农定理"><a href="#2-奈奎斯特定理与香农定理" class="headerlink" title="2.奈奎斯特定理与香农定理"></a>2.奈奎斯特定理与香农定理</h2><ol>
<li><p>奈奎斯特定理:定义了没有噪声，带宽有限情况下，为避免码间串扰的极限传输速率。<br>公式为:极限传输速率&#x3D;2W*log2(V),W为带宽，V为码元的离散电平数(即这种码元的最大组合个数)。</p>
<blockquote>
<p>tips：奈式定理告诉我们，如果需要提高信息传输率，应该提高比特的信息量。</p>
</blockquote>
</li>
<li><p>香农定理:给出了带宽有限且受到噪声干扰的极限数据传输速率.<br>公式为:信道极限传输速率&#x3D;Wlog2(1+S&#x2F;N),W为带宽，S为信号平均功率，N为信道内部的高斯噪声功率。</p>
</li>
</ol>
<p>特别值得注意的是,S&#x2F;N是没有单位的，想要要带入香农定理需要经过转化，信噪比(带单位sB)&#x3D;10log10(S&#x2F;N)，比如S&#x2F;N&#x3D;1000,转化&#x3D;10*log10(S&#x2F;N)&#x3D;30db。</p>
<blockquote>
<p>tips:奈式讲的是无干扰环境下，码元与带宽的传输速率。香浓指的是受到干扰的情况下，带宽极限传输速率。</p>
</blockquote>
<hr>
<h2 id="3-编码与调制"><a href="#3-编码与调制" class="headerlink" title="3.编码与调制"></a>3.编码与调制</h2><ol>
<li>调制:数据变换成模拟信号。</li>
<li>编码:数据变换成数字信号。<blockquote>
<p>tips:相应的信号可以转化成别的信号传输，也可以通过放大调制器进行输出。</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>tips2:数字信号编码用于基带传输</p>
</blockquote>
<ol start="3">
<li>编码方式：值得注意的是，以下编码方式的1，0表示方式可以互相转换，比如原本表示0的电平表示1.</li>
</ol>
<ul>
<li>1.归零编码(RZ):高电平代表1，低电平代表0，每个时钟周期中必然跳到0，所以1，0根据每个时钟周期开始的电平判断。同时自带同步时钟信号(因为双方传输需要)。</li>
<li>2.非归零编码(NRZ):即每个时钟周期中间不会归零，难以同步，若想高速同步数据需要自带时钟线。</li>
<li>3.反向非归零编码(NRZI):信号变化为0，不变化为1.</li>
<li>4.曼切斯特编码:将一个码元分成两个相等的间隔，前半高，后半第为1。前半低，后半高为0.<br>值得注意的是，曼切斯特编码的间隔可以作为时钟信号同步，而它所占的频带宽度是原始基带宽度的两倍，并且以太网使用的编码方式为曼切斯特编码。</li>
<li>5.差分曼切斯特编码:前半分与上一个周期的电平相等为1，不同为0.<br>值得注意的是：局域网使用差分曼切斯特编码传输，并且可以使用自同步。</li>
<li>6.4B&#x2F;5B编码，每4位作为一组，按照4B&#x2F;5B编码规则转化位5位码。</li>
</ul>
<ol start="4">
<li>数字数据调制为模拟信号</li>
</ol>
<ul>
<li>1.幅移键控(ASK)，频移键控(FSK)，相移键控(PSK)。</li>
<li>2.主要要点为为正交振幅调制(QAM)：即在频率相同的前提下，将ASK和PSK结合起来。形成叠加信号。设波特率为B，采用m个相位，每个相位n个振幅，则QAM技术的传输速率R&#x3D;Blog2(mn)。<blockquote>
<p>tips:主要考点为给出QAM传输速率，给出相位和振幅，可以得出波特率。<br>而波特率(码元传输速率)，如果知道码元代表的离散值可以求出传输速率。</p>
</blockquote>
</li>
</ul>
<ol start="5">
<li><p>模拟信号转化成数字信号：包括采样，量化，编码。<br>语言数字化技术为QAM</p>
<blockquote>
<p>值得注意的是，采样频率必须大于最大频率的两倍，才能保证采样后的数字信息完整保留原始模拟信号的信息。</p>
</blockquote>
</li>
<li><p>模拟数据调制为模拟信号：可以使用频分复用技术。</p>
</li>
</ol>
<hr>
<h2 id="4-电路交换，报文交换，分组交换。"><a href="#4-电路交换，报文交换，分组交换。" class="headerlink" title="4.电路交换，报文交换，分组交换。"></a>4.电路交换，报文交换，分组交换。</h2><ol>
<li>电路交换：需要建立一条专用并且双方独占的物理通信路径。</li>
</ol>
<ul>
<li>1.电路交换的三个阶段：1.连接建立。2.数据传输。3.连接释放。</li>
<li>2.主要优点：1.时延小。2.有序传输。</li>
<li>3.主要缺点:1.建立连接时间长。2.效率低。</li>
</ul>
<ol start="2">
<li>报文交换:交换单位是报文。</li>
</ol>
<ul>
<li>1.主要优点:1.无需建立连接。2.动态分配线路。3.提高利用率。</li>
<li>2.主要缺点:1.对报文没有限制，报文过大导致，排队转发时延可能过大。3.失序</li>
</ul>
<ol start="3">
<li>分组交换：与报文交换相比设置了数据块上限，有效提高了数据传输速率(比如重传而消耗的时间，比如排队时延，转发时延。)</li>
</ol>
<blockquote>
<p>tips:分组交换和报文交换都是储存转发。</p>
</blockquote>
<ol start="4">
<li>分组交换之数据报与虚电路。</li>
<li>数据报和虚电路是分组交换的两种传输方法。</li>
</ol>
<ul>
<li>1.数据报:高层会将报文拆成若干个带有序号的数据单元，加上控制信息形成数据报分组(即网络层的PDU).</li>
<li>2.将数据报与电路交换方式结合起来。分组发送前需要经历:1.虚电路建立。2.数据传输。3.虚电路释放。每个分组多了虚电路号，而虚电路上的每个结点也有维护一张虚电路表。</li>
</ul>
<hr>
<h2 id="5-错题"><a href="#5-错题" class="headerlink" title="5.错题"></a>5.错题</h2><ol>
<li>一个信道每1&#x2F;8秒采样一次，传输信号16种变化状态，最大数据传输率为:<br>8s*log2(16)&#x3D;64。采样为得到带宽8hz，不需要除以2。</li>
</ol>
<hr>
<h2 id="6-传输介质"><a href="#6-传输介质" class="headerlink" title="6.传输介质"></a>6.传输介质</h2><ol>
<li><p>传输介质也称传输媒体，在数据传输系统中发送设备和接收设备之间的物理通路。<br>传输介质分为：1.导向型传输介质(沿着固体媒介传播，比如光纤)。2.非导向型传输介质(可以是空气，真空，海水等。)。</p>
</li>
<li><p>光纤</p>
</li>
</ol>
<ul>
<li>1.多模光纤：不同角度入射的多条光纤，只适合短距离传输。</li>
<li>2.单模光纤:直线传播，适合远距离传输。</li>
</ul>
<ol start="3">
<li>物理层的接口特定:</li>
</ol>
<ul>
<li>1.机械特性:指明接口所用接线器的形状，尺寸，引脚数目和排列，固定和锁定装置。</li>
<li>2.电气特性:指明在接口电缆的各条线上的电压范围。</li>
<li>3.功能特性:指明某条线上某一电平的电压表示何种意义。</li>
<li>4.过程特性:或许规程特性，用于指明可能事件的顺序。</li>
</ul>
<hr>
<h2 id="7-物理层设备"><a href="#7-物理层设备" class="headerlink" title="7.物理层设备"></a>7.物理层设备</h2><ol>
<li>中继器:两个端口(出入)，用于将数字信号放大(整形再生)。<blockquote>
<p>tips1:中继器连接的是网段，而非子网，因此多个中继器连接的几个网段属于同一个局域网。因此两端必须使用同一个协议。</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>tips2:放大器用于模拟信号，中继器放大数字信号。</p>
</blockquote>
<ol start="2">
<li>集线器：本质上是一个多端口的中继器，并且处理数据处于半双工状态，因此网络得到吞吐率也会受到限制。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/05/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%8E%8B%E9%81%93%E5%A4%8D%E4%B9%A0%E6%8C%87%E5%AF%BC/%E8%80%83%E7%A0%94-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuanSchuan">
      <meta itemprop="description" content="既然选择远方，便不顾风雨亦兼程">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="川山">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/05/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%8E%8B%E9%81%93%E5%A4%8D%E4%B9%A0%E6%8C%87%E5%AF%BC/%E8%80%83%E7%A0%94-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/" class="post-title-link" itemprop="url">考研-计算机网络体系</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-05 14:14:07 / 修改时间：14:16:41" itemprop="dateCreated datePublished" datetime="2022-11-05T14:14:07+08:00">2022-11-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">计算机网络考研复习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="注意：这部分为习题该书习题的总结，包涵部分补充。"><a href="#注意：这部分为习题该书习题的总结，包涵部分补充。" class="headerlink" title="注意：这部分为习题该书习题的总结，包涵部分补充。"></a>注意：这部分为习题该书习题的总结，包涵部分补充。</h2><hr>
<h2 id="1-计算机网络概念"><a href="#1-计算机网络概念" class="headerlink" title="1.计算机网络概念"></a>1.计算机网络概念</h2><ol>
<li>计算机网络是将一些互联，自治的计算机系统组成的集合，进而实现资源共享。<blockquote>
<p>tips:数据通信是网络最基础和最重要的功能，包括资源共享只不过是这个功能的衍生。</p>
</blockquote>
</li>
<li>根据计算机的发展阶段，而发展中从广义观点-&gt;资源共享观点-&gt;用户透明性观点而对计算机的定义。</li>
</ol>
<ul>
<li>1.广义观点为：能够实现远程信息处理和资源共享的系统均是计算机网络。</li>
<li>2.资源共享观点：包涵目的，组成单元和网络协议。</li>
<li>3.用户透明性：即整个计算机网络中的资源对于连接该网络的计算机是透明的。</li>
</ul>
<hr>
<h2 id="2-计算机网络的组成"><a href="#2-计算机网络的组成" class="headerlink" title="2.计算机网络的组成"></a>2.计算机网络的组成</h2><ol>
<li>从组成部分看分为：硬件,软件,协议。</li>
</ol>
<ul>
<li>1.硬件部分包括主机(端系统),通信链路，交换设备(比如路由器),通信处理机(网卡)。</li>
<li>2.软件大多在应用层</li>
<li>3.协议：值得注意的是，协议是组成部分计算机网络的核心。</li>
</ul>
<ol start="2">
<li>从工作方式看：边缘部分和核心部分.</li>
</ol>
<ul>
<li>1.边缘部分为互联网中的主机组成，主要作用为进行通信和资源共享。</li>
<li>2.核心部分为大量网络和路由器组成。</li>
</ul>
<ol start="3">
<li>从功能组成看:通信子网和资源子网。</li>
</ol>
<ul>
<li>1.通信子网主要就是通讯部分组成，比如传输介质，通信设备，协议等。</li>
<li>2.资源子网主要为实现资源共享功能的设备及其软件的集合。</li>
</ul>
<blockquote>
<p>tips:计算机网络的功能主要包括:1.数据通信。2.资源共享。3.分布式处理。4.提高可靠性(即互联网中的计算机可互为替代机)。5.负载均衡。值得注意的是，数据通信是计算机网络的最基础和最重要功能，后面的那么功能均可以视为数据通信的衍生。</p>
</blockquote>
<hr>
<h2 id="3-计算机网络的分类"><a href="#3-计算机网络的分类" class="headerlink" title="3.计算机网络的分类"></a>3.计算机网络的分类</h2><ol>
<li>按分布范围分类：1.广域网(远程网)-&gt;2.城域网-&gt;3.局域网-&gt;4.个人区域网。<blockquote>
<p>tips1:广域网使用的是点对点技术，局域网使用的是广播技术。</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>tips2:城域网大多数采用以太网技术，因此大多数也将城域网放入局域网讨论。</p>
</blockquote>
<blockquote>
<p>tips3:如果中央处理器的距离非常近，比如小于1m，那么一般称为多处理器系统，而不称为计算机网络。</p>
</blockquote>
<ol start="2">
<li><p>按照传输技术分类：点对点和广播.</p>
<blockquote>
<p>tips1:点对点不一定要主机相连，是指通过中间节点进行接收，储存转发。</p>
</blockquote>
</li>
<li><p>按照拓扑结构分类</p>
</li>
</ol>
<ul>
<li><ol>
<li>网状拓扑结构指网络节点和通信线路之间的几何关系。</li>
</ol>
</li>
<li><ol start="2">
<li>分类分为1.总线形。2.星形。3.环形。4.网状。<blockquote>
<p>tips1:网状一般用于广域网。</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<blockquote>
<p>tips2:总线形和环形本质上都是一条线连接多个主机，星形则是一个中央设备连接多个主机。网状结构是一个节点可以连接多个其他节点形成。</p>
</blockquote>
<blockquote>
<p>tips3:以上基本的4种网络拓扑结构能够形成更复杂的网络。</p>
</blockquote>
<ol start="4">
<li>按照交换技术分类</li>
</ol>
<ul>
<li>1.电路交换网络：一条电路连接两个短缺，特点是比特流直达，但信道利用率低。</li>
<li>2.报文交换网络。</li>
<li>3.分组交换网络：形成多个小的分组进行储存转发。而报文交换则是将收到整个报文后才进行储存转发。</li>
</ul>
<ol start="5">
<li>按照传输介质分类：1.有线。2.无线。</li>
</ol>
<blockquote>
<p>tips：计算机网络标准的4个阶段：1.互联网草案。2.建议标准。3.草案建议标准。4.因特网标准。</p>
</blockquote>
<hr>
<h2 id="4-计算机网络性能指标。"><a href="#4-计算机网络性能指标。" class="headerlink" title="4.计算机网络性能指标。"></a>4.计算机网络性能指标。</h2><ol>
<li>速率，带宽，吞吐率的区别：</li>
</ol>
<ul>
<li>1.速率单位为bit&#x2F;s，为当前传输的比特速度。</li>
<li>2.带宽为最大的速率。</li>
<li>3.吞吐率指某个单位时间的实际数据率，包括受时延的影响的数据率影响，并且单位之间不一定是1s。</li>
</ul>
<hr>
<h2 id="5-错题"><a href="#5-错题" class="headerlink" title="5.错题"></a>5.错题</h2><ol>
<li>计算机网络种没有:1.客户机2.服务器。3.操作系统。4.数据库管理系统。</li>
</ol>
<ul>
<li>没有4.数据库管理系统。</li>
</ul>
<ol start="2">
<li>计算机的网络的拓扑结构主要取决于它的<br>1.资源子网。2.路由器。3.通信资源。4.交换机。</li>
</ol>
<ul>
<li>3.通信子网。原因参照通信子网的定义。</li>
</ul>
<ol start="3">
<li>广播式网络错误的是：1.共享广播信道。2.不存在路由选择问题。3.可以不要网络层。4.不需要网络服务点：</li>
</ol>
<ul>
<li>选择4.值得注意的是，因为广播式网络一般用于局域网，因此不存在需要路由和网络层的问题。</li>
</ul>
<hr>
<h2 id="6-计算机网络体系结构与参考模型"><a href="#6-计算机网络体系结构与参考模型" class="headerlink" title="6.计算机网络体系结构与参考模型"></a>6.计算机网络体系结构与参考模型</h2><ol>
<li>在计算机的分层结构中，最低层称为1层，依次累加。在第n层的活动元素通常称为第n层实体。<blockquote>
<p>tips:实体指任何可发送或者接收信息的硬件或软件进程，通常是一个特定的软件模块。</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>tips2:不同机器上的同一层称为对等层。同一层的实体称为对等实体。</p>
</blockquote>
<ol start="2">
<li><p>在计算机的所有分层中，其中传递报文都分为两部分SDU(服务数据单元,即数据)和PCI(协议控制单元,即控制部分，一般为首部)。合起来称为PDU(协议数据单元)。</p>
<blockquote>
<p>tips:PDU在每一层的称呼不同，比如物理层为比特，数据链路层为帧，网络层为分组，传输层为报文段。</p>
</blockquote>
</li>
<li><p>网络协议，接口和服务的概念。</p>
</li>
</ol>
<ul>
<li>1.协议：规则的集合，由语法，语义，同步三部分组成。在同一层的同一实体间运行。</li>
<li>2.接口：同一个结点内相邻两层交换信息的连接点。</li>
<li>3.服务:可以理解为特殊的接口，下层为上层的提供的功能调用。<blockquote>
<p>tips:协议是水平的，服务是垂直的。<br>tips:并非在一层的所有功能都是服务，只有高层实体’看见’的的功能才称为服务。</p>
</blockquote>
</li>
</ul>
<ol start="4">
<li><p>面向连接和无连接服务：是否需要预先建立连接，面向连接需要(比如TCP)。无连接不需要(比如UDP,IP)</p>
</li>
<li><p>可靠服务和不可靠服务:可靠服务即提供纠错，检错，应答机制。不可靠服务即尽量尽量正确的</p>
</li>
</ol>
<blockquote>
<p>tips:1.TCP就是面向连接+可靠服务协议。2.UDP就是无连接服务+不可靠服务。</p>
</blockquote>
<ol start="6">
<li>有应答服务和无应答服务：有应答服务是指接收方在收到数据后向发送方给出相应的应答。无应答则不会对接收的数据进行回应。</li>
</ol>
<hr>
<h2 id="7-ISO-x2F-OSI参考模型和TCP-x2F-IP协议。"><a href="#7-ISO-x2F-OSI参考模型和TCP-x2F-IP协议。" class="headerlink" title="7.ISO&#x2F;OSI参考模型和TCP&#x2F;IP协议。"></a>7.ISO&#x2F;OSI参考模型和TCP&#x2F;IP协议。</h2><ol>
<li>ISO&#x2F;OSI：开放系统互联参考模型，第三层为通信子网，其余高层为资源子网。</li>
</ol>
<ul>
<li>1.层次为:1.物理层-&gt;2.数据链路层-&gt;3.网络层-&gt;4.传输层-&gt;5.会话层-&gt;6.表示层<br>-&gt;7.应用层</li>
<li>物理层：屏蔽材料的各种差距，实现比特流的透明传输。<br>值得注意的是，物理层也是有协议的，该协议主要包涵通信链路与通信结点，通信链路上传输的信号和电气特征。</li>
<li>数据链路层:传输单位为帧,主要任务是将网络层传来的IP数据报组成帧，主要功能为:成帧，差错控制，流量控制，和传输管理。<br>值得注意的是，广播式网络包涵控制对共享信道的访问。数据链路层为此有一个特殊的字层，介质访问层。</li>
<li>网络层:传输单位为数据报，它关心通信子网的运行控制，主要任务为把网络层的协议数据单元(分组)从源端传递到目的端。主要功能为进行路由选择，并实现流量控制，拥塞控制，差错控制，网际互联等操作。</li>
<li>传输层:也称为运输层，传输单位是报文段(TCP)或者用户数据报(UDP),主要负责主机间进程的通信，功能为端到端连接提供可靠的传输服务，为端到端连接提供流量控制，差错储存，服务质量，数据传输管理。</li>
<li>会话层:会话层允许不同主机上的各个进程之间进行对话。</li>
<li>表示层:主要处理两个通信系统中交换信息的表示方式。比如不同机器采用的编码，数据结构，相互交换。</li>
<li>应用层:是用户与网络的界面，因此使用的协议也最多。</li>
</ul>
<blockquote>
<p>tips:数据链路层的差错控制为:传输过程中原始的比特流可能发生错误，如果发生错误，那么数据链路层的协议会发现并直接丢弃。而网络层的差错控制为:两个结点约定的差错控制，如果能够纠错就纠错，不能纠错就丢弃。传输层的差错控制为会使用协议对差错进行校验，丢弃和重传等操作。<br>区别在于数据链路层针对原始比特流，网络层针对网络分组的头部，传输层(如果使用TCP协议)针对收到的报文段</p>
</blockquote>
<blockquote>
<p>tips2:数据链路层的流量控制是控制发送速率，使得接收方不会来不及接收发送方发送的数据。网络层的拥塞控制为控制传输的流量，防止随着流量的增加而降低信道传输效率，最后直接堵塞。<br>传输层的控制为专有协议控制信息的接收，防止缓冲溢出。</p>
</blockquote>
<ol start="2">
<li>TCP&#x2F;IP模型为：1.网络接口层-&gt;2.网际层-&gt;3.传输层-&gt;4.应用层。</li>
</ol>
<ul>
<li>1.TCP网络接口层对应ISO&#x2F;OSI的物理层和数据链路层。</li>
<li>2.网际层对应网络层</li>
<li>3.应用层对ISO应用层+表示层+会话层</li>
</ul>
<blockquote>
<p>tips：OSI模型在网络层支持面向连接和无连接通信，但在传输层仅只有面向连接通信。而TCP模型认为可靠性是端到端的问题，因此它在网际层只有一种无连接的通信模式，面向连接由传输层支持。</p>
</blockquote>
<blockquote>
<p>tips2:数据链路层提供点到点通信(主机之间的通信，点指一个硬件地址或IP地址)，而传输层提供端到端服务(进程之间的通信)。</p>
</blockquote>
<blockquote>
<p>tips3:TCP&#x2F;IP模型为事实上的国际标准</p>
</blockquote>
<hr>
<h2 id="8-错题"><a href="#8-错题" class="headerlink" title="8.错题"></a>8.错题</h2><ol>
<li>不是网络分层的目标为：2.因为具体的功能为分层具体实现，不作标准化，因而也不是分层的主要目标。</li>
</ol>
<ul>
<li>1.提供标准语言</li>
<li>2.定义功能执行的方法</li>
<li>3.定义标准界面</li>
<li>4.增加功能之间的独立性</li>
</ul>
<ol start="2">
<li>OSI模型的数据链路层功能为：4 即保证源比特流的完整</li>
</ol>
<ul>
<li>1.提供用户和网络的接口</li>
<li>2.处理信号通过介质的传输</li>
<li>3.控制报文通过网络的路由选择</li>
<li>4.保证数据正确的顺序和完整性</li>
</ul>
<ol start="3">
<li>TCP&#x2F;IP模型的网络层提供的是</li>
</ol>
<ul>
<li>1.无连接不可靠的数据报服务</li>
<li>2.无连接可靠的数据报服务</li>
<li>3.无连接不可靠的虚电路服务</li>
<li>4.有连接可靠的虚电路服务<blockquote>
<p>tips:连接为两个结点是否会预先通信一遍</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>tips2:可靠为:是否会进行纠错，重传等服务</p>
</blockquote>
<blockquote>
<p>tips3:虚电路是指逻辑上的数据电路(具有需要建立连接，一直占用通信资源效率低，但时延低的特性。)，而分组转发的网络层使用的是数据报服务。</p>
</blockquote>
<ol start="4">
<li><p>路由器在网络层，交换机在链路层，集线器在物理层。</p>
</li>
<li><p>TCP协议的要素的连接过程要点一般只有时序，没有语义和语法。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/7-CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuanSchuan">
      <meta itemprop="description" content="既然选择远方，便不顾风雨亦兼程">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="川山">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/7-CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/" class="post-title-link" itemprop="url">7.CPU的结构和功能</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-10-28 22:18:24 / 修改时间：22:25:10" itemprop="dateCreated datePublished" datetime="2022-10-28T22:18:24+08:00">2022-10-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-CPU功能"><a href="#1-CPU功能" class="headerlink" title="1.CPU功能"></a>1.CPU功能</h2><ul>
<li>1.取指令:控制器从储存器中取出指令</li>
<li>2.分析指令:即识别出操作码的作用和操作数地址由控制器发出操作命令。</li>
<li>3.执行指令:根据操作命令和操作地址的要求形成控制信号。</li>
<li>4.中断能力，<blockquote>
<p>tips:总之，CPU需要指令控制，操作控制，时间控制，数据加工和处理中断。</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="2-CPU结构"><a href="#2-CPU结构" class="headerlink" title="2.CPU结构"></a>2.CPU结构</h2><ol>
<li><p>CPU内部分别为:ALU(算数逻辑单元),寄存器，中断系统，CU(控制单元).与系统总线相连(包括控制总线，数据总线，地址总线)。</p>
</li>
<li><p>连接：</p>
</li>
</ol>
<ul>
<li>1.ALU部件(状态标志，移位，取反，算数和布尔逻辑)与CPU内部数据总线相连。</li>
<li>2.CPU内部数据总线与寄存器相连。</li>
<li>3.控制单元与寄存器和中断系统相连，并且通过控制信号与ALU和数据总线相连。</li>
<li>4.中断系统同时通过控制信号和数据总线和ALU相连。</li>
</ul>
<hr>
<h2 id="3-CPU的寄存器"><a href="#3-CPU的寄存器" class="headerlink" title="3.CPU的寄存器"></a>3.CPU的寄存器</h2><ol>
<li>寄存器分类为:用户可见寄存器和用户不可见寄存器。</li>
</ol>
<ul>
<li>1.用户可见寄存器为可对这些寄存器进行编程，主要用于减少CPU对主存的访问次数进而加快程序速度。</li>
<li>2.用户不可见寄存器属于控制和状态类寄存器，它们被控制部件使用以控制CPU，也可被带有特权的操作系统使用，进而控制程序的执行。</li>
</ul>
<ol start="2">
<li>用户可见寄存器</li>
</ol>
<ul>
<li>1.通用寄存器:由程序计数者指定功能，比如存放操作数，满足某种寻址方式所需要的寄存器。</li>
<li>2.数据寄存器:主要用于存放操作数</li>
<li>3.地址寄存器:用于存放地址，也具有通用性。</li>
<li>4.条件码寄存器:存放条件码，对用户来说是部分透明的。</li>
</ul>
<ol start="3">
<li>控制和状态寄存器(用户不可见寄存器):</li>
</ol>
<ul>
<li>1.MAR:储存器地址寄存器:用于存放要取出的数据单元的地址。</li>
<li>2.MDR:储存器数据寄存器:用于存放要存入或者读取于寄存器的数据。</li>
<li>3.PC:程序计数器:存放现行指令的地址，通过具有计数功能。</li>
<li>4.IR:存放当前欲执行的指令。<blockquote>
<p>tips:通过这4个寄存器，CPU和主存可交换信息。</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="4-控制单元和中断系统"><a href="#4-控制单元和中断系统" class="headerlink" title="4.控制单元和中断系统"></a>4.控制单元和中断系统</h2><ol>
<li>概述:控制单元(CU)是提供计算机完成全部指令操作的微操作命令序列部件。</li>
<li>现代计算机微操作命令序列的形成方法：</li>
</ol>
<ul>
<li>1.组合逻辑设计方法，为硬连线逻辑。</li>
<li>2.微程序设计方法，为储存逻辑。</li>
</ul>
<hr>
<h2 id="5-指令周期："><a href="#5-指令周期：" class="headerlink" title="5.指令周期："></a>5.指令周期：</h2><ol>
<li>基本概念：</li>
</ol>
<ul>
<li>1.指令周期：CPU取出一条指令并执行一条指令所需要的全部时间。</li>
<li>2.取指周期:完成取指令和分析指令的操作。</li>
<li>3.执行周期:完成执行指令操作的。<blockquote>
<p>tips:大多数情况CPU按:取指-&gt;执行-&gt;再取指-&gt;再执行…</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="6-指令周期的数据流"><a href="#6-指令周期的数据流" class="headerlink" title="6.指令周期的数据流:"></a>6.指令周期的数据流:</h2><ol>
<li>取指周期的数据流：</li>
</ol>
<ul>
<li>1.PC存放现行指令的地址，将该地址送到MAR并送至地址总线。</li>
<li>2.控制部件CU向储存器发出读命令，使对于的MAR所指单元内容(指令)经数据总线送至MDR,再送至IR,并且CU控制PC形成内容+1,形成下一条指令的地址。</li>
</ul>
<ol start="2">
<li>间址周期的数据流：</li>
</ol>
<ul>
<li>1.一旦取指周期结束，CU便检查IR中的内容，以确定是否有间址操作。</li>
<li>2.如果需要间址操作，则MDR中执行形式地址的右N位(记作Ad(MDR))将被送到MAR，又被送至地址总线，此后CU向储存器发出读命令，以获取有效地址并存至MDR。</li>
</ul>
<ol start="3">
<li>执行周期的数据流:不同的指令在执行周期的操作不同，因此执行周期的数据流可能是多种多样的。</li>
<li>中断周期的数据流:PC当前的内容必须保存起来，以待执行中断服务程序后可以准确返回到该程序的间断处。</li>
</ol>
<hr>
<h2 id="7-流水线性能"><a href="#7-流水线性能" class="headerlink" title="7.流水线性能"></a>7.流水线性能</h2><ol>
<li>吞吐率:单位时间内流水线所完成指令或者输出结果的数量。</li>
</ol>
<ul>
<li>1.实际吞吐率:流水线完成n条指令的实际吞吐率。</li>
<li>2.最大吞吐率:流水线在连续流动的达到稳定后所获得的吞吐率。</li>
</ul>
<ol start="2">
<li><p>加速比：流水线的加速比是指m段流水线的速度与等功能的非流水线速度之比。</p>
</li>
<li><p>效率:指流水线各功能段的利用率。</p>
</li>
<li><p>流水线的多发技术</p>
</li>
</ol>
<ul>
<li>1.超标量技术：每个时钟周期内可同时并发多条独立指令。</li>
<li>2.超流水线技术：将流水线寄存器插入流水线段中。</li>
<li>3.超长指令字技术<blockquote>
<p>tips:值得注意的是，超长指令字技术和超标量技术都采用多条指令在多个处理部件中并行处理的体系结构。</p>
</blockquote>
</li>
</ul>
<ol start="5">
<li>流水线结构：</li>
</ol>
<ul>
<li>1.指令流水线结构:指令流水线是指指令的整个执行过程用流水线进行分段处理。</li>
<li>2.运算流水线:指令流水线是指运算的整个执行过程用流水线进行分段处理。</li>
</ul>
<hr>
<h2 id="8-中断系统"><a href="#8-中断系统" class="headerlink" title="8.中断系统"></a>8.中断系统</h2><ol>
<li>中断类型</li>
</ol>
<ul>
<li>1.人为设置的中断：一般称为自愿中断。</li>
<li>2.程序性事故：比如定点溢出，浮点溢出。</li>
<li>3.硬件故障:比如接触不良，通风不良。</li>
<li>4.IO设备:每个IO设备都能够发中断请求。</li>
<li>5.外部事件:比如键盘中断现行程序。</li>
</ul>
<ol start="2">
<li>中断请求标记和中断逻辑判优:</li>
</ol>
<ul>
<li>1.中断请求标记，设置中断请求标记触发器，简称中断请求触发器：用于标记不同的中断类型。</li>
<li>2.中断判优逻辑：按照优先顺序进行排序判断。</li>
</ul>
<ol start="3">
<li><p>值得注意的是，中断请求既可以使用硬件排队，又可以使用软件排队。</p>
</li>
<li><p>中断服务程序入口地址的寻找有两种寻找方法：硬件向量法和软件查询法。</p>
</li>
</ol>
<ul>
<li>1.硬件向量法：利用硬件产生向量地址，在由向量地址产生中断服务程序的入口地址。</li>
<li>2.软件查询法：软件查找中断服务程序入口地址的方法称为软件查询法。</li>
</ul>
<ol start="5">
<li>响应中断</li>
</ol>
<ul>
<li>1.需要设置中断的条件。</li>
<li>2.中断请求不是立即有回应，需要响应中断的时间。</li>
<li>3.中断的隐指令：1.保护程序断点(即将当前内容的PC内容保护到储存器中)。2.寻找中断服务程序的入口地址。3.关中断，即关闭中断请求，避免cpu在本次中断未完成前响应其他中断。</li>
</ul>
<ol start="6">
<li>保护现场和恢复现场:</li>
</ol>
<ul>
<li>1.保护现场为:保护程序断点和CPU内部各个寄存器内容。</li>
<li>2.恢复现场：将寄存器内容恢复到中断前的状态。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yuanSchuan</p>
  <div class="site-description" itemprop="description">既然选择远方，便不顾风雨亦兼程</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yuanSchuan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
