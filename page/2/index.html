<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="既然选择远方，便不顾风雨亦兼程">
<meta property="og:type" content="website">
<meta property="og:title" content="川山">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="川山">
<meta property="og:description" content="既然选择远方，便不顾风雨亦兼程">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yuanSchuan">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>川山</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">川山</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuanSchuan">
      <meta itemprop="description" content="既然选择远方，便不顾风雨亦兼程">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="川山">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">6.指令系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-10-28 22:18:08 / 修改时间：22:20:09" itemprop="dateCreated datePublished" datetime="2022-10-28T22:18:08+08:00">2022-10-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机组成原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-机器指令概述"><a href="#1-机器指令概述" class="headerlink" title="1.机器指令概述"></a>1.机器指令概述</h2><ol>
<li>概述：机器语言由一条条语句构成，每一条语句准确的表达某种语义。语义表达某种操作。全部的机器指令集合称为机器的指令系统，指令系统集反应了机器的功能。</li>
</ol>
<hr>
<h2 id="2-指令的一般格式-操作码字段和地址码字段"><a href="#2-指令的一般格式-操作码字段和地址码字段" class="headerlink" title="2.指令的一般格式:操作码字段和地址码字段"></a>2.指令的一般格式:操作码字段和地址码字段</h2><ol>
<li>操作码：用来指明该指令所要完成的操作。比如加法，移位等操作。</li>
<li>地址码:用来指明该指令的原操作地址，地址可以是主存地址，寄存器地址，甚至是IO地址。</li>
</ol>
<ul>
<li>1.三地址指令：一般为第一个地址和第二个地址的数据进行OP(某种运算),存入第三个地址。</li>
<li>2.两地址指令:第一个地址与第二个地址进行运算，并将结果存入第一个地址。</li>
<li>3.一地址指令:存放运算的操作数，存放运算的中间结果。</li>
<li>4.零地址指令:比如空操作，停机等指令。</li>
</ul>
<hr>
<h2 id="3-操作数类型"><a href="#3-操作数类型" class="headerlink" title="3.操作数类型"></a>3.操作数类型</h2><ol>
<li>地址：地址实际上也是一种数据。</li>
<li>数字</li>
<li>字符：普遍采用ASCII码</li>
<li>逻辑数据:逻辑运算时，n个0,1的组合不被看作算数，而是逻辑数。</li>
</ol>
<hr>
<h2 id="4-数据在储存器中的存放方式"><a href="#4-数据在储存器中的存放方式" class="headerlink" title="4.数据在储存器中的存放方式"></a>4.数据在储存器中的存放方式</h2><ol>
<li>概述：字长一定是2的倍数，对于没有满足字长长度的数据，需要进行填充。</li>
</ol>
<hr>
<h2 id="5-操作类型"><a href="#5-操作类型" class="headerlink" title="5.操作类型"></a>5.操作类型</h2><ol>
<li>数据传送:包括在寄存器和储存单元之间传送数据。</li>
<li>算数逻辑运算</li>
<li>移位</li>
<li>转移：跳转至相应的指令段执行</li>
</ol>
<ul>
<li>1.无条件转移</li>
<li>2.条件转移</li>
<li>3.调用与返回</li>
<li>4.陷阱与陷阱指令：意外中断</li>
<li>5.输入输出</li>
</ul>
<hr>
<h2 id="6-寻址方式"><a href="#6-寻址方式" class="headerlink" title="6.寻址方式"></a>6.寻址方式</h2><ol>
<li>指令寻址:</li>
</ol>
<ul>
<li>1.顺序寻址:即通过PC+1,自动形成下一条指令的地址。</li>
<li>2.通过转移指令实现</li>
</ul>
<ol start="2">
<li>数据寻址:操作码+寻址特征+形式寻址,又称形式地址，因为地址码字段通常不代表操作数的真实地址。</li>
</ol>
<ul>
<li>1.立即寻址：即立即数(不是操作数地址，而是操作数本身)</li>
<li>2.直接寻址：数据的真实地址</li>
<li>3.隐含寻址:不明显的操作数地址，隐含在某个操作码或者地址数中。</li>
<li>4.间接寻址:储存的是数据的储存地址的储存单元。</li>
<li>5.寄存器寻址：指明了寄存器编号,取某个寄存器的值。</li>
<li>6.寄存器间接寻址:取寄存器中的值在，将这个值视作地址进行查询。</li>
<li>7.基址查询:需要基址寄存器BR,形式地址与基址寄存器相加。</li>
<li>8.变址寻址:形式地址与变址寄存器内容相加。</li>
<li>9.相对寻址:将PC中的内容与形式地址相加。</li>
</ul>
<ol start="3">
<li>关于RISC和CISC比较的优点：</li>
</ol>
<ul>
<li>1.充分利用VLSI芯片面积</li>
<li>2.提高计算机运算速度</li>
<li>3.便于设计，可降低成本，提高可靠性。</li>
<li>4.有效支持高级语言<blockquote>
<p>tips:RISC是CISC在某种程度上精简。</p>
</blockquote>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuanSchuan">
      <meta itemprop="description" content="既然选择远方，便不顾风雨亦兼程">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="川山">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/" class="post-title-link" itemprop="url">5.中央处理器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-10-28 22:17:56 / 修改时间：22:19:30" itemprop="dateCreated datePublished" datetime="2022-10-28T22:17:56+08:00">2022-10-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机组成原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-无符号数和符号数"><a href="#1-无符号数和符号数" class="headerlink" title="1.无符号数和符号数"></a>1.无符号数和符号数</h2><ol>
<li>概述：计算机中的数均存放在寄存器中，通常称寄存器的位数为机器字长。无符号数，每一位均可用来存放数值，有符号数，需要留出位置存放符号。</li>
</ol>
<hr>
<h2 id="2-有符号数"><a href="#2-有符号数" class="headerlink" title="2.有符号数"></a>2.有符号数</h2><ol>
<li>原码表示：符号位0表示正数，1表示负数。</li>
</ol>
<ul>
<li>1.原码表示整数：符号位,数值位。正数符号为0,负数位1，</li>
<li>2.原码表示小数：符号位.数值位。</li>
</ul>
<ol start="2">
<li>补码表示：符号位,数值位。符号位0表示正数，1表示负数(1必然负数，因为2进制的原因，2的最高位必然比之后所有数加起来还多1)。</li>
</ol>
<ul>
<li>1.补码表示正数:0,数值位</li>
<li>2.补码表示负数:1,数值位。<blockquote>
<p>tips:正数数值位就是数值，负数的比如101为-2^2+1&#x3D;-3</p>
</blockquote>
</li>
</ul>
<ol start="3">
<li>反码表示法：主要用于原码和补码之间的中间过渡。</li>
</ol>
<ul>
<li>1.反码表示正数，符号位,数值位。数值位为原码或者补码原本的数值位。</li>
<li>2.反码表示负数，符号位,数值位。数值位获取为最高位+2的次方-1+原本的数值位。<blockquote>
<p>tips：采用定点数的机器为定点机。</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="3-定点数表示"><a href="#3-定点数表示" class="headerlink" title="3.定点数表示"></a>3.定点数表示</h2><ol>
<li>定点数:</li>
</ol>
<ul>
<li>1.格式1(纯整数)：数符(符号位)+数值部分+.(小数点位置)。</li>
<li>2.格式2(纯小数):数符(符号位)+.(小数点位置)+数值部分。</li>
</ul>
<hr>
<h2 id="4-浮点数表示"><a href="#4-浮点数表示" class="headerlink" title="4.浮点数表示"></a>4.浮点数表示</h2><ol>
<li>浮点数：即小数点的位置可以浮动的数。</li>
<li>浮点数的表示：N(浮点数)&#x3D;S(尾数,可正可负)+r(基数)^j(阶码,可正可负)</li>
</ol>
<p>比如：N&#x3D;11.0101可写成如下形式<br>0.110101<em>2^10<br>1.10101</em>2^1<br>1101.01*2^-10</p>
<blockquote>
<p>tips:相信你也看见了后面的尾数越多，精确度越高<br>3. 格式：阶符+阶码的数值部分+数符(小数点位置)+尾数的数值部分。<br>tips:因为计算机为二进制，即基数基本都是2,8,16…因此，浮点数事实上由阶码(包括符号)和尾数(包括符号)组成。</p>
</blockquote>
<ol start="4">
<li><p>规格化：尾数最高位为1,比如上述的0.110101*2^10为N的规格化数</p>
</li>
<li><p>定点数和浮点数的比较：</p>
</li>
</ol>
<ul>
<li>1.相同的位数，浮点数表示的范围比定点数大得多。</li>
<li>2.浮点数为规格化数时，相对精度比定点数高。</li>
<li>3.浮点运算因为分尾数和阶码两部分运算，因此速度比定点慢。</li>
<li>4.浮点数的溢出判断为判读阶码，而定点数对其本身进行判断。</li>
</ul>
<hr>
<h2 id="5-定点运算"><a href="#5-定点运算" class="headerlink" title="5.定点运算"></a>5.定点运算</h2><ol>
<li>移位运算：左移为1位*2，2位为*4，右移为1位&#x2F;2，2位为&#x2F;4</li>
</ol>
<ul>
<li>1.正数移位运算：左移还是右移都是添加0。</li>
<li>2.负数移位运算：有符号数移位为算数右移(即高位添1)，无符号数为逻辑右移(即高位填0)</li>
</ul>
<ol start="2">
<li><p>加法与减法运算：使用补码进行加法运算时，将符号位当作数值位运算即可。</p>
<blockquote>
<p>tips:减一个数视作+一个负数。</p>
</blockquote>
</li>
<li><p>乘法运算：可视为加法和移位运算，比如11*10&#x3D;0(不移位)*11+1(移一位)*11</p>
<blockquote>
<p>tips:符号位单独处理</p>
</blockquote>
</li>
<li><p>除法运算</p>
<blockquote>
<p>tips:符号位单独处理</p>
</blockquote>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuanSchuan">
      <meta itemprop="description" content="既然选择远方，便不顾风雨亦兼程">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="川山">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">4.输入输出系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-10-27 21:37:25 / 修改时间：21:39:08" itemprop="dateCreated datePublished" datetime="2022-10-27T21:37:25+08:00">2022-10-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机组成原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-输入输出系统的发展概况"><a href="#1-输入输出系统的发展概况" class="headerlink" title="1.输入输出系统的发展概况"></a>1.输入输出系统的发展概况</h2><ol>
<li>早期：IO设备与主存设备交换信息必须通过CPU。</li>
</ol>
<ul>
<li>具有以下特点</li>
<li>1.每个IO设备都必须配备一套独立的逻辑电路与CPU相联</li>
<li>2.输入输出过程穿插在CPU执行过程中进行，进而不得不暂停CPU的工作，浪费CPU的工作时间。</li>
<li>3.IO设备与CPU连接十分紧密，变成了一个不可分割的整体，更换IO设备十分困难。</li>
</ul>
<p>DMA:Direct Memory Access:直接访问储存器<br>2. 接口模块和DMA阶段：接口模块和DAM阶段：</p>
<ul>
<li>特点：</li>
<li>1.计算机采用总线结构，IO设备通过接口与总线相连进而与主机交互。</li>
<li>2.IO设备与主存之间有一条直接的数据通路。</li>
</ul>
<ol start="3">
<li><p>通道结构阶段：通道类似于一种特殊功能的处理器，但又不完全独立，从属于CPU，CPU不直接管理，用于负责IO设备以及实现主存与IO设备之间的信息交换。中小型计算机一般使用DMA即可，而通道一般用于中大型计算机。</p>
</li>
<li><p>具有IO处理机的阶段：IO处理机又称外围处理机(Periheral Processor)，基本独立于主机工作，既可以完成IO通道又要完成IO控制，完成码制变换，格式处理，数据块检错，纠错等操作。于CPU并行的工作性更高。</p>
</li>
</ol>
<hr>
<h2 id="2-输入输出系统的组成："><a href="#2-输入输出系统的组成：" class="headerlink" title="2. 输入输出系统的组成："></a>2. 输入输出系统的组成：</h2><ol>
<li><p>概述：输入输出系统由IO硬件和IO软件两部分组成。</p>
</li>
<li><p>IO软件</p>
</li>
</ol>
<ul>
<li>(1)主要任务<ul>
<li>1.将用户编制的程序(或数据)输入到主机内</li>
<li>2.将运算结果输送到用户</li>
<li>3.实现输入输出系统与主机的协调。</li>
</ul>
</li>
<li>(2)软件指令:操作码+命令码+设备码，分为IO指令和通道指令</li>
<li>(3)IO指令作用<ul>
<li>将数据从IO设备输入主机</li>
<li>将数据从主机输出至IO设备</li>
<li>状态测试:比如利用命令码检测各个IO设备是否处于忙的状态，还是准备就绪状态，以便主机与IO交换设备交换信息。</li>
<li>形成某些操作命令:比如读，写文件。</li>
</ul>
</li>
<li>(4)通道指令:又称为通道控制字，对具有通道的IO系统专门设置的指令。</li>
</ul>
<ol start="3">
<li>IO硬件：对于带有接口Io系统，一般包括接口和IO设备两个部分。对于有通道的IO系统，一个通道与一个以上的设备控制器相连，控制设备又可控制若干个同一类型的设备。</li>
</ol>
<hr>
<h2 id="3-IO设备与主机的联系方式："><a href="#3-IO设备与主机的联系方式：" class="headerlink" title="3.IO设备与主机的联系方式："></a>3.IO设备与主机的联系方式：</h2><ol>
<li>IO设备的编址方式：通常将IO设备码看作地址码，用两种地址码的编址方式：统一编址和不统一编址。</li>
</ol>
<ul>
<li>1.统一编址：将IO地址看作储存器地址的一部分，</li>
<li>2.不统一编址：IO设备地址与储存器地址分开，对IO设备的访问有专门的IO指令。</li>
</ul>
<ol start="2">
<li><p>设备寻址：为每台设备赋予一个设备号，IO指令的设备码能够直接指出设备号，通过接口电路的设备选择电路，便可选中要交换的信息。</p>
</li>
<li><p>传送方式：并行传送和串行传送。</p>
</li>
</ol>
<ul>
<li>1.并行：多条线路一次传送多个比特。</li>
<li>2.串行：一条线路一次传送一个比特。</li>
</ul>
<ol start="4">
<li>联络方式：3种：(1)立即响应。(2)异步工作采用应答应答信号联络。(3)同步工作采用同步时标联络。</li>
</ol>
<ul>
<li>1.立即响应：IO指令一到，立即响应。</li>
<li>2.应答信号：IO设备与CPU各自完成自身的任务，一旦出现联络信号，彼此才准备交换信息，这种一问一答的联络方式称为异步联络。</li>
<li>3.同步时标联络：使用专用电路产生同步时标来控制同步工作。</li>
</ul>
<ol start="5">
<li>IO设备与主机的连接方式：1.辐射式(每个IO设备都有一套控制线路和信号线，一般出现在计算机发展的初始阶段)。2.总线式(通过一组总线，将所有的IO设备与主机连接)。</li>
</ol>
<hr>
<h2 id="4-IO设备与主机信息传送的控制方式"><a href="#4-IO设备与主机信息传送的控制方式" class="headerlink" title="4.IO设备与主机信息传送的控制方式"></a>4.IO设备与主机信息传送的控制方式</h2><p>概述：分为1.程序查询。2.程序中断。3.直接储存器存取。4.IO通道。5.IO处理机。</p>
<ol>
<li>程序查询方式：CPU不断查询IO设备是否准备，进而控制IO设备与主机交换信息。</li>
<li>程序中断方式：只有在IO设备准备就绪并向CPU发出中断信号才予以响应。</li>
<li>DMA方式：主存和IO设备之间有一条数据通路，若DMA与CPU同时访问内存，CPU会将总线控制权给DAM。</li>
</ol>
<hr>
<h2 id="5-IO接口"><a href="#5-IO接口" class="headerlink" title="5.IO接口"></a>5.IO接口</h2><ol>
<li>概述:两个系统或两步部件之间的交接部分，既可以是硬件设备之间的连接，也可以是软件之间共同的逻辑边界。IO设备可以使用设备控制器中的IO接口与主机取得联系</li>
<li>接口的作用：</li>
</ol>
<ul>
<li>1.一台机器通常配有多台IO设备，通过接口实现IO设备选择。</li>
<li>2.通过接口实现数据缓冲，提高数据利用率。</li>
<li>3.串行和并行转换。比如CPU一般使用并行，而IO设备困难使用串行。</li>
<li>4.实现电平转换。</li>
<li>5.通过接口传送控制命令。</li>
<li>6.监视工作状态，保存状态信息。</li>
</ul>
<blockquote>
<p>tips:接口和端口的不同概念：端口指接口电路中的一些寄存器，用来存放数据信息，控制信息和状态信息。相应的端口也称为数据端口，控制端口，状态端口。若干个端口加上相应的控制逻辑组成接口。CPU通过输入指令，从端口读入信息，通过输出指令，可将信息写入端口中。</p>
</blockquote>
<ol start="3">
<li>接口的组成</li>
</ol>
<ul>
<li>1.数据线：IO设备和主机之间的数据代码传送线。</li>
<li>2.设备选择线：传送设备码</li>
<li>3.命令线：用于传送CPU发向设备的命令信号。</li>
<li>4.状态线：IO设备的状态向主机报告的信号线。</li>
</ul>
<ol start="4">
<li>接口的功能</li>
</ol>
<ul>
<li>1.选址功能：即CPU通过设备选择线上的设备码确定。</li>
<li>2.传送命令功能：命令线。</li>
<li>3.传送数据的功能：数据线。</li>
<li>4.反映IO设备的工作状态的功能线:状态线。</li>
</ul>
<ol start="5">
<li>按数据传送分类：</li>
</ol>
<ul>
<li>1.并行接口</li>
<li>2.串行接口</li>
</ul>
<ol start="6">
<li>按功能类型分类：</li>
</ol>
<ul>
<li>1.可编程接口</li>
<li>2.不可编程接口</li>
</ul>
<ol start="7">
<li>按通用性分类：</li>
</ol>
<ul>
<li>1.通用接口</li>
<li>2.专用接口</li>
</ul>
<ol start="8">
<li>按数据传送的方式分类：</li>
</ol>
<ul>
<li>1.程序型接口</li>
<li>2.DMA接口：Direct Memory Access</li>
</ul>
<hr>
<h2 id="6-程序查询方式"><a href="#6-程序查询方式" class="headerlink" title="6.程序查询方式"></a>6.程序查询方式</h2><ol>
<li>概述：需要不断查询IO设备是否准备就绪。</li>
<li>查询指令</li>
</ol>
<ul>
<li>1.测试指令：用于查询是否就绪</li>
<li>2.传送指令：执行传送指令</li>
<li>3.转移指令：若IO设备未准备就绪，执行转移指令，转至测试指令。</li>
</ul>
<ol start="3">
<li>过程</li>
</ol>
<ul>
<li>1.先将寄存器原内容保护起来。</li>
<li>2.设置IO设备与主机交换数据的计数值。</li>
<li>3.设置欲传送的数据在主存缓存区的首地址。</li>
</ul>
<p>以上为准备工作</p>
<ul>
<li>4.CPU启动IO设备</li>
<li>5.将IO接口中的设备状态标志取至CPU并测试IO设备是否准备就绪。</li>
<li>6.CPU执行IO指令</li>
<li>7.修改主存地址</li>
<li>8.修改计数值</li>
<li>9.判断计数值</li>
<li>10.结束IO传送</li>
</ul>
<hr>
<h2 id="7-程序中断方式的接口电路："><a href="#7-程序中断方式的接口电路：" class="headerlink" title="7.程序中断方式的接口电路："></a>7.程序中断方式的接口电路：</h2><ol>
<li>中断请求触发器：用于外部设备。</li>
<li>中断屏蔽触发器：CPU每次只能处理一个中断请求，多余的需要排队并且对CPU屏蔽。</li>
<li>排队器：对中断请求进行排队</li>
<li>中断向量地址形成部件(设备编码器).</li>
</ol>
<hr>
<h2 id="8-中断服务程序的流程"><a href="#8-中断服务程序的流程" class="headerlink" title="8.中断服务程序的流程"></a>8.中断服务程序的流程</h2><ol>
<li>保护现场：1.保存程序的断点，保存通用寄存器和状态寄存器。</li>
<li>中断服务(设备服务)：对不同中断请求源，提供不同的中断服务。</li>
<li>恢复现场：将中断时的现场恢复到原来的寄存器中。</li>
<li>中断返回：返回原程序的断点处。<br>DMA:Direct Memory Access:直接访问储存器</li>
<li>DMA使用的三种方式：</li>
</ol>
<ul>
<li>1.停止CPU访问主存：DMA要求CPU停止访问数据，DMA传送数据至无。</li>
<li>2.周期挪用：IO获取总线占用权几个周期。</li>
<li>3.DMA和CPU交替访问。</li>
</ul>
<hr>
<h2 id="9-DMA接口功能和组成"><a href="#9-DMA接口功能和组成" class="headerlink" title="9.DMA接口功能和组成"></a>9.DMA接口功能和组成</h2><ol>
<li>DMA接口介绍：数据传输过程完全由DMA接口控制，故而DMA接口又称为DMA控制器。</li>
<li>DMA接口功能：</li>
</ol>
<ul>
<li>1.向CPU申请DMA传送。</li>
<li>2.向CPU允许DMA工作时，处理总线控制权的转交。</li>
<li>3.在DMA控制总线传送时，控制数据传送。</li>
<li>4.修正数据传送过程的地址和数据长度。</li>
<li>5.数据传送结束时，发送结束信号。</li>
</ul>
<ol start="3">
<li>DMA接口的基本组成：</li>
</ol>
<ul>
<li>1.主存地址寄存器(AR)：用于存放在主存中需要交换数据的地址。</li>
<li>2.字计数器:记录传送数据的总字数。</li>
<li>3.数据缓冲寄存器(BR):暂存每次传送的数据。</li>
<li>4.DMA控制逻辑:DMA控制逻辑负责管理DMA的传送过程。</li>
<li>5.中断机构：由中断机构向CPU提出中断请求。</li>
<li>6.设备地址寄存器(DAR):存放IO设备的设备码和表示设备信息储存区的寻址信息。</li>
</ul>
<hr>
<h2 id="10-DMA的工作过程"><a href="#10-DMA的工作过程" class="headerlink" title="10.DMA的工作过程"></a>10.DMA的工作过程</h2><ol>
<li>DMA的传送过程：</li>
</ol>
<ul>
<li>1.预处理：即执行初始化过程，1.指明数据传送方向,输入，输出。2.送入设备号，并启动设备。3.DMA主存的起始地址。</li>
<li>2.数据传送</li>
<li>3.后处理</li>
</ul>
<ol start="2">
<li>DMA与程序中断方式的特点:</li>
</ol>
<ul>
<li>1.从数据传送来看，数据中断方式依靠程序传送，DMA依靠硬件传送。</li>
<li>2.从CPU响应时间来看，程序中断方式指一条指令执行结束时响应。而DMA方式可在指令周期内任一存取周期结束时响应。</li>
<li>3.程序中断方式有处理异常事件的能力，DMA没有这种能力。</li>
<li>4.程序中断方式需要中断现行程序，故需要保护现场，DMA方式不中断现行程序，无需保护现场。</li>
<li>5.DMA中断优先级比程序中断的优先级高。</li>
</ul>
<hr>
<h2 id="11-DMA接口类型"><a href="#11-DMA接口类型" class="headerlink" title="11.DMA接口类型"></a>11.DMA接口类型</h2><ol>
<li>概述：现代集成电路技术已将DMA接口制成芯片，通常分为选择型和多路型两类。</li>
</ol>
<ul>
<li>1.选择型DMA接口：在物理上可连接多个设备，逻辑上只允许连接一个设备。</li>
<li>2.多路型DMA接口：在物理上可连接多个设备，逻辑上也允许多个设备同时工作。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3-%E5%82%A8%E5%AD%98%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuanSchuan">
      <meta itemprop="description" content="既然选择远方，便不顾风雨亦兼程">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="川山">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3-%E5%82%A8%E5%AD%98%E5%99%A8/" class="post-title-link" itemprop="url">3.储存器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-10-27 21:37:12 / 修改时间：21:38:33" itemprop="dateCreated datePublished" datetime="2022-10-27T21:37:12+08:00">2022-10-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机组成原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-储存器分类"><a href="#1-储存器分类" class="headerlink" title="1.储存器分类"></a>1.储存器分类</h2><ol>
<li>按照储存介质分类</li>
</ol>
<ul>
<li>1.半导体储存器:易失性储存器。</li>
<li>2.磁表面储存器:非易失性储存器。</li>
<li>3.磁芯储存器：永久记忆储存器（现在已经不再使用）</li>
<li>4.光盘储存器:非易失性储存器。<blockquote>
<p>tips:易失：断电后数据丢失。非易性数据：断电后数据依旧存在。</p>
</blockquote>
</li>
</ul>
<ol start="2">
<li>按存取方式分类：</li>
</ol>
<ul>
<li>1.随机储存器：任何一个储存单元的内容都可以随机存取。</li>
<li>2.只读储存器：只读储存器只能对储存的内容进行读取，不能重新写入。</li>
<li>3.串行访问储存器：按照物理位置先后顺序寻找地址。（又称顺序存取储存器）。</li>
<li>4.直接存取储存器：比如磁盘的磁道对前段直接访问。</li>
</ul>
<ol start="3">
<li>按照作用分类：</li>
</ol>
<ul>
<li>1.主储存器：可以直接与CPU直接进行信息交换。</li>
<li>2.辅助储存器：主储存器的后援储存器，用于存放当前暂时不用的程序和数据，但不能与CPU直接交换信息。</li>
<li>3.缓冲储存器：主要用于两个不同速度的部件中，中和过大的速度差距，起到缓冲的作用。</li>
</ul>
<hr>
<h2 id="2-主储存器"><a href="#2-主储存器" class="headerlink" title="2.主储存器"></a>2.主储存器</h2><ol>
<li><p>读取数据过程：CPU将该字的地址发送至MAR,经地址总线送至主存，然后发出读命令，主存接到读命令后，按照地址单元完成读操作并且将单元的内容送到地址总线上。</p>
</li>
<li><p>主存的主要技术指标：1.储存容量。2.储存速度。</p>
</li>
</ol>
<ul>
<li><p>1.储存容量:&#x3D;储存单元个数*储存字长。或者&#x3D;储存单元个数*储存字长&#x2F;8</p>
</li>
<li><p>2.储存速度：存取时间和存取周期示。<br>存取时间称为储存器访问时间，指储存器完成一次操作到完成该操作所需要的全部时间。存取时间又分为读取时间和写入时间。</p>
<p>存取周期是指：储存器连续进行两次独立储存器操作。</p>
</li>
</ul>
<ol start="3">
<li>储存器带宽：单位时间内储存器存取的信息量。</li>
</ol>
<hr>
<h2 id="3-随机存取储存器-Random-adress-Memories"><a href="#3-随机存取储存器-Random-adress-Memories" class="headerlink" title="3.随机存取储存器(Random adress Memories)"></a>3.随机存取储存器(Random adress Memories)</h2><ol>
<li><p>主要分类为1.静态RAM和2.动态RAM</p>
</li>
<li><p>静态RAM：信息读出后，仍保存原状态，不需要再生。电源断电时，原存信息会丢失。故它属易失性半导体储存器。</p>
</li>
<li><p>动态随机RAM：需要不断刷新电容，以恢复一次原状态。</p>
<blockquote>
<p>tips:静态和动态的区别在于动态需要不断刷新电容以维持信息状态，而静态不需要。</p>
</blockquote>
</li>
</ol>
<hr>
<h2 id="4-只读储存器-ROM"><a href="#4-只读储存器-ROM" class="headerlink" title="4.只读储存器(ROM)"></a>4.只读储存器(ROM)</h2><ol>
<li>简介：随着需要出现了能够任意改变ROM的原始信息。</li>
<li>ROM信息出现：PROM,EPROM,EEPROM</li>
</ol>
<ul>
<li>1.PROM：一次性编程的只读储存器。</li>
<li>2.EPROM:可擦除可编程只读储存器</li>
<li>3.RRPROM:快擦型储存器。</li>
</ul>
<blockquote>
<p>tips:储存器的校验使用汉明码进行校验。</p>
</blockquote>
<hr>
<h2 id="5-高速缓冲储存器"><a href="#5-高速缓冲储存器" class="headerlink" title="5.高速缓冲储存器"></a>5.高速缓冲储存器</h2><ol>
<li><p>概念：因为IO设备向主存请求级别高于CPU，致使CPU出现出现一段空等的时间,而主存可提前将CPU要使用的数据存入高速缓存中,一旦主存与IO设备交换时，CPU可直接从高速缓存中读取所需信息，不必空等而影响效率。</p>
</li>
<li><p>工作原理：主存被划分成若干块，若干块分为若干字。形成一部分的对于缓存的映射。CPU会先访问缓存Cache，如果缓冲命中，将直接从缓冲复制到CPU。如果不命中，那么就访问主存，将这个块映射到缓冲储存器复制到CPU。</p>
</li>
<li><p>Cache的基本结构：1.Cache储存体。2.地址映射变换机构。3.替换机构。4.Cache的读写操作。</p>
</li>
<li><p>Cache的主存地址映射：1.直接映射。2.全相联映射。3.组相联映射。</p>
</li>
</ol>
<ul>
<li>1.直接映射：每个主存块只能固定的对应某个缓存块，缓存空间得不到充分的利用。</li>
<li>2.全相联映射：允许主存中每一个字块映射到Cache中任何一个位置上，但逻辑电路较多，成本较高。</li>
<li>3.组相联映射：直接映射和全相联映射的一种折中。又称为二路组相联。</li>
</ul>
<ol start="5">
<li>替换策列：当缓存满时，需要使用替换策略，分别为：1.先进先出(即先进先出)。2.近期最少使用(近期最少使用的被替代)。3.随机法(随替换)。</li>
</ol>
<hr>
<h2 id="6-辅助储存器"><a href="#6-辅助储存器" class="headerlink" title="6.辅助储存器"></a>6.辅助储存器</h2><ol>
<li><p>概念：辅助储存器又称为外部储存器。与主存相比，具有容量大，速度慢，价格低的特点，可脱机保存，属于易失性储存器。</p>
</li>
<li><p>辅助储存器分类：1.硬磁盘储存器。2.软磁盘储存器。3.磁带储存器。4.光盘储存器。</p>
<blockquote>
<p>tips:磁表面由于磁介质表面的缺陷，尘埃等原因，采用循环冗余校验码。</p>
</blockquote>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2-%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuanSchuan">
      <meta itemprop="description" content="既然选择远方，便不顾风雨亦兼程">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="川山">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2-%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/" class="post-title-link" itemprop="url">2.系统总线</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-10-24 09:30:40 / 修改时间：09:33:43" itemprop="dateCreated datePublished" datetime="2022-10-24T09:30:40+08:00">2022-10-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机组成原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-总线的基本概念"><a href="#1-总线的基本概念" class="headerlink" title="1.总线的基本概念"></a>1.总线的基本概念</h2><ol>
<li>计算机各个部件之间的连接方式</li>
</ol>
<ul>
<li>1.分散连线：各个部件之间的单独连线。</li>
<li>2.总线连接：将各个部件连接到一组公共信息传输线。</li>
</ul>
<ol start="2">
<li>总线介绍：</li>
</ol>
<ul>
<li>1.储存总线：连接CPU和主存。</li>
<li>2.输出总线：建立CPU和各个IO设备之间的交换通道。</li>
</ul>
<ol start="3">
<li>总线分类：</li>
</ol>
<ul>
<li><p>1.片内总线：芯片内部的总线。比如cpu芯片内部，寄存器与寄存器之间，寄存器与算逻单元之间都由片内总线连接。</p>
</li>
<li><p>2.系统总线：系统总线又分为数据总线，地址总线，控制总线。</p>
<ul>
<li>1.数据总线：用来传输各功能部件之间的数据信息。</li>
<li>2.地址总线：主要用来指出数据总线上的源数据或目的数据在主存单元的地址或IO设备的地址。</li>
<li>3.控制总线:用于发出各种控制信号的传输线。</li>
</ul>
</li>
<li><p>3.通信总线：主要用于计算机系统与其他系统(比如控制仪器)之间的通信。</p>
<blockquote>
<p>tips:通信总线的传输方式分为：串行通信和并行通信。串行通信指一条传输线一个个传输，并行指多条传输线一个个传输。</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="2-总线特性："><a href="#2-总线特性：" class="headerlink" title="2.总线特性："></a>2.总线特性：</h2><ol>
<li>机械特性：指机械连接方式上的一些性能，比如插头和插座的使用标准。</li>
<li>电气特性：每一根传输线上信号的传递方向和有效的电平范围。</li>
<li>功能特性：传输线的功能，比如地址总线用来指出地址码。</li>
<li>时间特性：用于指出什么时间内有效。</li>
</ol>
<hr>
<h2 id="3-总线性能指标"><a href="#3-总线性能指标" class="headerlink" title="3.总线性能指标"></a>3.总线性能指标</h2><ol>
<li>总线宽度：数据总线的根数，用bit表示。比如8位，16位。</li>
<li>总线带宽：总线的数据传输速率：单位时间内总线上传输数据的位数。</li>
<li>时钟同步&#x2F;异步：同步：数据与时钟同步工作。与时钟不同步工作的总线位异步总线。</li>
<li>总线复用：一条信号线上分时传送两种信号。</li>
<li>信号线数：即地址总线，数据总线，控制总线三种总线数的总和。</li>
<li>总线的控制方式：突发工作，自动配置。</li>
<li>其他指标：比如负载能力。</li>
</ol>
<hr>
<h2 id="4-总线结构"><a href="#4-总线结构" class="headerlink" title="4.总线结构"></a>4.总线结构</h2><ol>
<li>总线结构通常可分为单总线结构和多总线结构。</li>
<li>单总线特点在于将所有的IO设备都挂在了一起。</li>
<li>多总线结构的特点在于将速度较低的IO设备从单总线上分离，形成主存总线与IO总线分开的结构。</li>
</ol>
<hr>
<h2 id="5-总线控制"><a href="#5-总线控制" class="headerlink" title="5.总线控制"></a>5.总线控制</h2><p>前提：总线上连接的各类设备按照对总线有无控制功能分为：主设备(对总线有控制功能)，从设备(对总线无控制功能)。</p>
<ol>
<li><p>总线判优控制分为集中式和分布式：1.集中式：控制逻辑集中在一起。分布式：将控制逻辑分散在与总线连接的各个部件和设备上。</p>
</li>
<li><p>集中控制的三种仲裁方式：</p>
</li>
</ol>
<ul>
<li>1.链式查询：离总线控制部件越近的设备具有最高优先级。</li>
<li>2.计时器定时查询：在总线未被使用的情况下，总线控制部件的计时器会开始计时并通过设备地址线向各个设备发出一组地址信号，当某个请求占据总线设备地址与计数器一致时，获得总线使用权。</li>
<li>3.独立请求方式：每一台设备均有一对总线请求线BR和总线同意线BG。</li>
</ul>
<hr>
<h2 id="6-总线通信控制"><a href="#6-总线通信控制" class="headerlink" title="6.总线通信控制"></a>6.总线通信控制</h2><ol>
<li>经过的周期：</li>
</ol>
<ul>
<li>1.申请分配阶段，由需要使用总线的主模块提出申请，经总线仲裁机构决定将总线使用授权于某一申请者。</li>
<li>2.寻址阶段，取得了使用权的主模块通过总线</li>
<li>3.传数阶段：主模块与从模块进行数据交换。</li>
<li>4.结束阶段：主模块相关信息从系统总线撤出，让出总线使用权。</li>
</ul>
<ol start="2">
<li><p>同步通信：由统一时标控制数据传送称为同步通信。</p>
</li>
<li><p>异步通信：没有公共时钟标准，采用应答方式(又称握手方式)，即当主模块发出请求信号时，一直等待从模块返回响应信号后才开始通信。</p>
</li>
<li><p>异步通信的应答方法</p>
</li>
</ol>
<ul>
<li>1.不互锁方式：主模块发送请求信号后，不必等待从模块的回答。</li>
<li>2.半互锁方式：主模块发出请求信号后，必须等到从模块回答信号后再撤销其请求信号。</li>
<li>3.全互锁方式：主模块发出请求信号后，必须等到从模块回答信号后再撤销其请求信号。并且从模块必须获知主模块请求信号撤销后，再撤销其回答，双方存在互锁关系。</li>
</ul>
<ol start="5">
<li>半同步通信：既像同步通信一样保留地址命令发出的时间，都按照参照时钟的某个前沿开始，又像异步通信一样允许不同速度的工作，并且为此增加了一条等待”wait”响应时间线。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%A6%82%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuanSchuan">
      <meta itemprop="description" content="既然选择远方，便不顾风雨亦兼程">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="川山">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%A6%82%E8%AE%BA/" class="post-title-link" itemprop="url">概论</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-10-24 09:30:24 / 修改时间：09:32:44" itemprop="dateCreated datePublished" datetime="2022-10-24T09:30:24+08:00">2022-10-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机组成原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-计算机的软硬件概念及层次结构"><a href="#1-计算机的软硬件概念及层次结构" class="headerlink" title="1.计算机的软硬件概念及层次结构"></a>1.计算机的软硬件概念及层次结构</h2><ol>
<li><p>计算机系统由硬件和软件两部分组成。</p>
<blockquote>
<p>tips:软件由系统软件和应用软件组成。</p>
</blockquote>
</li>
<li><p>计算机层次:高级语言-&gt;汇编语言-&gt;机器语言(微程序解释机器指令)-&gt;微程序(硬件直接执行)</p>
</li>
<li><p>冯.诺依曼计算机:</p>
</li>
</ol>
<ul>
<li>1.计算机由运算器，储存器，控制器，输入设备，输出设备组成。</li>
<li>2.指令和数据以同等地位存放在储存器内，并且可以按地址寻找</li>
<li>3.指令和数据均用二进制表示</li>
<li>4.指令由操作码和地址码组成。其中操作码表示指令性质，地址码表示操作数在储存器的位置。</li>
<li>5.指令顺序存放顺序执行，可以按照特定条件，根据运算结果或者条件改变执行顺序。</li>
<li>6.机器以运算器为中心，输入输出设别与储存器间的数据传送通过运算器完成。</li>
</ul>
<blockquote>
<p>tips1:1运算器用汉语完成算数和逻辑运算，并且能够暂时将中间结果储存在运算器内。<br>2储存器用于储存数据和程序。<br>3控制器用来控制和指挥程序，数据的输入，运行以及处理运算结果。<br>4输入设备用来将人们熟悉的信息转化成机器能够识别的信息。<br>5输出设备可将机器运算结果转化成人们熟悉的信息形式。  </p>
</blockquote>
<blockquote>
<p>tips2:<br>运算器和控制器合称为中央处理器(CPU),输入与输出设备简称IO设备。<br>CPU与主储存器合起来称为主机，而IO设备又可称为外部设备。</p>
</blockquote>
<blockquote>
<p>tips3:主储存器又称主存，用于存放程序与数据，直接与CPU交换信息。另一类称为辅助储存器，简称为辅存，又称外存。</p>
</blockquote>
<blockquote>
<p>tips4:算数逻辑单元(Arithmatic Logic Unit ALU)：主要用于完成算数逻辑运算。控制单元(Control Unit CU):用于解释储存器中指令，并且发出各种操作命令执行指令。ALU和CU是CPU的核心部件。<br>值得注意的是：IO设备也受CU控制。</p>
</blockquote>
<hr>
<ol start="2">
<li>一些基础介绍</li>
</ol>
<ul>
<li><p>1.机器字长：指CPU一次能够处理的数据位数，通常与CPU的寄存器位数有关，一般是8的倍数。</p>
</li>
<li><p>2.主储存器：也称主存或者内存。包括储存体M，各种逻辑部件以及控制电路。 </p>
<p>储存器由储存单元组成，储存单元包涵若干个储存元件，每个储存元件可以表示1或者0.一个储存单元储存的一串二进制数为一个字长。</p>
<p>为实现按地址储存，主存中配置了MAD(memory address register)和MDR(memory data register)。MAR用于储存储存器的地址，MDR:用于储存从储存器取出的数据。</p>
</li>
<li><p>3.储存容量：主存容量和容量，其中主存容量是指主存中存放的二进制代码总数&#x3D;储存单元数*储存字长。辅助容量通常用字节数表示。</p>
</li>
<li><p>4.运算速度：计算所有相应指令占所有操作的百分比*指令i的执行时间。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/21/Internet/4-%E7%BD%91%E7%BB%9C%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuanSchuan">
      <meta itemprop="description" content="既然选择远方，便不顾风雨亦兼程">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="川山">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/21/Internet/4-%E7%BD%91%E7%BB%9C%E5%B1%82/" class="post-title-link" itemprop="url">4.网络层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-21 11:34:29" itemprop="dateCreated datePublished" datetime="2022-10-21T11:34:29+08:00">2022-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-24 09:36:21" itemprop="dateModified" datetime="2022-10-24T09:36:21+08:00">2022-10-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-网络层提供的两种服务"><a href="#1-网络层提供的两种服务" class="headerlink" title="1.网络层提供的两种服务"></a>1.网络层提供的两种服务</h2><ol>
<li>分为虚电路服务(面向连接)和数据报服务(无连接)。</li>
<li>虚电路和数据报服务对比</li>
</ol>
<ul>
<li><ol>
<li>虚电路认为可靠通信应当由网络保证，数据报认为可靠通信由用户主机保证。</li>
</ol>
</li>
<li><ol start="2">
<li>虚电路必须建立连接，而数据报服务不需要建立连接。</li>
</ol>
</li>
<li><ol start="3">
<li>对于终点地址虚电路仅在建立阶段使用，每个分组使用短的虚电信号。数据报每个分组都有完整的地址，即IP地址。</li>
</ol>
</li>
<li><ol start="4">
<li>虚电路对所有分组按照同一线路进行转发，数据报每个分组独立查找转发表进行转发。</li>
</ol>
</li>
<li><ol start="5">
<li>当一个节点出现故障时，所有通过该节点的虚电路均不能工作。而对于数据报服务，出现故障的节点可能丢失分组，一些路由可能发生变化。</li>
</ol>
</li>
<li><ol start="6">
<li>虚电路的分组按照顺序到达终点。数据报的分组到达的顺序不一定按照发送顺序。</li>
</ol>
</li>
<li><ol start="7">
<li>端到端的差错处理和流量控制，虚电路服务可以由网络负责，也可以由用户主机负责。数据报服务则由用户主机负责。<blockquote>
<p>tips：网络层的设计要尽量的简单，向上层提供简单灵活的，无连接的，尽最大努力的交付数据报服务。可以看出，网络层并不提供服务质量承诺。<br>tips2:虚电路只是仿电路交换的逻辑连接，按照储存转发方式发送，并不是真正的物理连接。</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<hr>
<h2 id="2-网络层的两个层面"><a href="#2-网络层的两个层面" class="headerlink" title="2.网络层的两个层面"></a>2.网络层的两个层面</h2><ol>
<li>层面分为数据层面(转发层面)和控制层面。</li>
</ol>
<ul>
<li><ol>
<li>数据层面为转发表转发数据。</li>
</ol>
</li>
<li><ol start="2">
<li>控制层面为路由器使用的路由算法创建转发表。</li>
</ol>
</li>
</ul>
<ol start="2">
<li>路由器之间传输的数据分类2类:</li>
</ol>
<ul>
<li><ol>
<li>目的主机与源主机之间所传送的数据。</li>
</ol>
</li>
<li><ol start="2">
<li>传送路由信息。<blockquote>
<p>tips1:路由器无法单独创建转发表，必须依靠彼此协同动作。<br>tips2:在控制层方面出现了逻辑上集中的远程控制器，掌控整个网络，可以直接在路由器上直接生成转发表。而路由器只需要接收，查表，转发。不过这种技术只用于超大型数据的转发而已，广泛的普及目前来看并没有优势和可能。</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<hr>
<h2 id="3-网际协议IP-Internet-Protocol-简介。"><a href="#3-网际协议IP-Internet-Protocol-简介。" class="headerlink" title="3.网际协议IP(Internet Protocol)简介。"></a>3.网际协议IP(Internet Protocol)简介。</h2><ol>
<li>与IP配套使用的三个协议</li>
</ol>
<ul>
<li>1.地址解析协议ARP(Adress Resolution Protocol)<br>:主要用于将IP地址与MAC地址转换。</li>
<li>2.网际控制报文协议ICMP(Internet Control Message Protocol)</li>
<li>3.网际组管理协议IGMP(Internet Group Management Protocol)<blockquote>
<p>tips:逆地址解析协议RAPP(Reverse Adress Resolution Protocol)ICMP已经包涵1的功能</p>
</blockquote>
</li>
</ul>
<ol start="2">
<li>中间设备的介绍：</li>
</ol>
<ul>
<li>1.物理层的中间设备:转发器</li>
<li>2.数据链路层的中间设备：网桥，桥接器，交换机。</li>
<li>3.网络层的中间设备:路由器</li>
<li>4.网络层以上的中间设备:网关<blockquote>
<p>tips:物理层或者链路层的中间设备仅仅只是把一个网络扩大了而已，并不能称为网络互联。<br>tips2:网络，包括局域网，城域网，广域网等。<br>tips3:历史原因，有许多文件将网络层的路由器称为网关，实际上二者是不同的，注意。</p>
</blockquote>
</li>
</ul>
<ol start="3">
<li>虚拟互联网络:逻辑互联网络，将物理性各异的结构互联起来，使得他们在网络层好像一个统一的网络。<br>两种交付方式：</li>
</ol>
<ul>
<li>1.间接交付:目的地是路由器，包括源主机到第一个路由器的交付。</li>
<li>2.直接交付:目的地是目的主机。</li>
</ul>
<h2 id="值得注意的是，每一次转发都称为跳-hop-常常使用下一跳-next-hop-gt-tips-互联网可以由多种异构网络互联而成。"><a href="#值得注意的是，每一次转发都称为跳-hop-常常使用下一跳-next-hop-gt-tips-互联网可以由多种异构网络互联而成。" class="headerlink" title="值得注意的是，每一次转发都称为跳(hop)常常使用下一跳(next hop)&gt;tips:互联网可以由多种异构网络互联而成。"></a>值得注意的是，每一次转发都称为跳(hop)常常使用下一跳(next hop)<br>&gt;tips:互联网可以由多种异构网络互联而成。</h2><h2 id="4-IP地址及其表示方法"><a href="#4-IP地址及其表示方法" class="headerlink" title="4.IP地址及其表示方法"></a>4.IP地址及其表示方法</h2><ol>
<li>IP地址由互联网名字和数据分配机构ICANN(Internet Corporation for Assigned Names and Numbers)分配。</li>
<li>IP地址类似给与每一台主机的一个接口，分配一个在世界范围内32位的唯一标识符。</li>
<li>点分十进制计法(dotted decimal notation),比如128.11.3.31转化过程为</li>
</ol>
<ul>
<li><ol>
<li>机器中存放的连续的二进制代码表示IP</li>
</ol>
</li>
<li><ol start="2">
<li>每8位视为一个处理单位，并以空格隔开。</li>
</ol>
</li>
<li><ol start="3">
<li>将8位一个二进制转化成十进制</li>
</ol>
</li>
<li><ol start="4">
<li>将空格转化为.</li>
</ol>
</li>
</ul>
<ol start="4">
<li><p>IP地址组成为:网络号+主机号<br>网络号用来表示该IP地址连接的网络，主机号为该网络下的某台主机。</p>
<blockquote>
<p>tips：关于多类地址，比如A类地址，通过网络号和主机号的比例分配不同确定。其中D类地址为多播地址，其余为单播地址，即点对点通信。</p>
</blockquote>
</li>
<li><p>特殊的IP地址。</p>
</li>
</ol>
<ul>
<li><ol>
<li>网络全0+主机号全0：表示本网络的本主机。</li>
</ol>
</li>
<li><ol start="2">
<li>网络全0+主机号x；表示本网络上主机号为X的主机。</li>
</ol>
</li>
<li><ol start="3">
<li>网络127(即01111111,主机号非全1和全0的任何数):用于本地软件的回环测试。</li>
</ol>
</li>
<li><ol start="4">
<li>网络全1+主机全1：仅在本网络进行广播</li>
</ol>
</li>
<li><ol start="5">
<li>Y+主机全1:对网络号为Y的主机进行广播</li>
</ol>
</li>
</ul>
<ol start="6">
<li>无分类编址方法CIDR(Classless Inter-Domain Routing)</li>
</ol>
<ul>
<li><ol>
<li>术语:</li>
</ol>
<ul>
<li><ol>
<li>网络前缀:即网络号，不向IP地址的X类分类那么固定。</li>
</ol>
</li>
<li><ol start="2">
<li>斜记线法&#x2F;,IP地址&#x2F;x，表示前X位为IP地址。</li>
</ol>
</li>
<li><ol start="3">
<li>地址块：网路前缀一样的连续IP被划分到同一个地址块。</li>
</ol>
</li>
<li><ol start="4">
<li>地址掩码：又称子网掩码：用于快速计算出IP地址。使用按位and算法，比如IP地址为11001,掩码为11100，那么网络地址就是11000。<blockquote>
<p>tips:掩码与IP地址同位，每有一位网络位填1，没有后全部填0.</p>
</blockquote>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<ol start="7">
<li><p>路由聚合：只用一个项目就可以表示原来传统分址的许多地址，因而大大压缩了转发表占用空间，减少查找转发表时间。</p>
<blockquote>
<p>tips:区分的原因在于可能有机构会得到多个网络地址，会优先寻找较长的地址，如果找不到就在聚合地址里面。</p>
</blockquote>
</li>
<li><p>IP地址的特点</p>
</li>
</ol>
<ul>
<li><ol>
<li>网络前缀+主机号组成：分等级的结构地址。利用路由聚合减少查找转发表的时间。</li>
</ol>
</li>
<li><ol start="2">
<li>IP地址标识一台主机(或路由器)和一条链路的接口。如果一台主机同时连接两个网络，就要有两个IP地址，对于多个IP地址的主机称之为多归属主机。<blockquote>
<p>tips：路由器至少需要两个路由器。</p>
</blockquote>
</li>
</ol>
</li>
<li><ol start="3">
<li>一个网络或者子网的定义为相同网络前缀的主机集合，因此，用转发器和交换机连接起来的若干个局域网仍然是一个网络，因为局域网拥有同样的网络前缀。不同网络前缀必须用路由器相连。</li>
</ol>
</li>
</ul>
<p>由此：</p>
<ul>
<li><ol>
<li>局域网的主机或者路由器在IP地址中的网络前缀必须是同样的，即拥有同样的网络号。</li>
</ol>
</li>
<li><ol start="2">
<li>路由器总是具有两个或两个以上的IP地址，即每个IP地址都不同。</li>
</ol>
</li>
<li><ol start="3">
<li>无编号网络：又称匿名网络:32位中31位网络地址，只有1位主机位，标识两个主机，构成点对点的特殊网络。</li>
</ol>
</li>
</ul>
<ol start="9">
<li>IP地址和MAC地址</li>
</ol>
<ul>
<li><ol>
<li>简介:因为MAC已经固化到网卡的ROM中，因此MAC地址又称为硬件地址或物理地址。物理地址的反面就是虚拟地址，软件地址，逻辑地址(称IP地址为逻辑地址是因为IP地址是用软件实现的)。</li>
</ol>
</li>
</ul>
<blockquote>
<p>tips1:IP层抽象的互联网只能看到IP数据报，并且IP数据报的源地址和目的地不会因为多次路由而改变。<br>tips2:路由只会根据目的站的IP地址进行转发。<br>tips3:局域网的链路层只能看见MAC帧，IP数据报被封装到MAC帧中。<br>tips4:尽管互联在一起的网络MAC地址体系不同，但IP层抽象的互联网却屏蔽了下层这些很复杂的细节。</p>
</blockquote>
<ol start="10">
<li>地址解析协议ARP</li>
</ol>
<ul>
<li><ol>
<li>作用:在主机的ARP高速缓存中存放一个IP地址到MAC地址的映射表，并经常更新该映射表。用于将IP地址通过高速缓存映射转发表转化成MAC地址，并且配置该映射表。<blockquote>
<p>tips:目前每台主机都设有APR高速缓存，用于存放映射表。</p>
</blockquote>
</li>
</ol>
</li>
<li><ol start="2">
<li>地址解析的4中过程</li>
</ol>
<ul>
<li><ol>
<li>发送方为主机，要把IP数据报发送给同一网络的另一台主机，发送方在该局域网中广播，找到目的主机的MAC地址。</li>
</ol>
</li>
<li><ol start="2">
<li>发送方为主机，要把IP数据报发送给另一网络的另一台主机，在局域网广播，找到一个路由器的MAC地址，剩下工作由该路由器完成。</li>
</ol>
</li>
<li><ol start="3">
<li>发送方为路由器，要把IP数据报发送给同一网络的另一台主机，在该局域网内广播，得到目的主机的MAC地址。</li>
</ol>
</li>
<li><ol start="4">
<li>发送方为路由器，要把IP数据报发送给不同一网络的另一台主机，在该局域网内广播，得到目的路由器的MAC地址。<blockquote>
<p>tips:请求MAC的数据会发送自身的IP地址，MAC地址，并请求目标的IP地址和MAC地址。<br>tips2:为了减少通信量，主机A会在向目的通信的时候在ARP高速缓存MAS与IP映射，被接收的主机B在返回的时候也会将A的映射放入B的映射表中<br>tips3:ARC对映射表中的地址映射设置有生存时间。</p>
</blockquote>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<ol start="11">
<li>IP数据报首部的固定字段：</li>
</ol>
<ul>
<li><p>(1) 版本：占4位，指明IP的版本。</p>
</li>
<li><p>(2) 首部长度：用来表示首部长度。</p>
<blockquote>
<p>tips:因为IP首部固定部分为20字节，因此首部长度单位最小为5字节，当表示1111即15，表示为15个32位字长(字长与操作系统有关，32位一个字长为4字节。)</p>
</blockquote>
</li>
<li><p>(3) 区分服务:用来获取更好的服务，占8位。</p>
</li>
</ul>
<blockquote>
<p>tips:实际上没有被使用过。</p>
</blockquote>
<ul>
<li>(4) 总长度:指首部和数据之和的长度，表示的单位为字节，本身占16位。</li>
</ul>
<blockquote>
<p>tips:值得注意的是，因为所有链路层协议都规定了MTU最大传输单元，因此对于长度过大的数据会被切片传送，而数据报中的总长度&#x3D;每块切片的首部长度+数据长度</p>
</blockquote>
<ul>
<li><p>(5) 标识(identification):用于分片后的数据进行重组。:占16位</p>
<blockquote>
<p>tips:IP软件在储存器中有一个计时器，每产生一个数据报，计数器+1</p>
</blockquote>
</li>
<li><p>(6) 标志(flags)：占3位。最低为1表示还有分片，0表示没有分片了。次低1表示不能分片，0表示可以分片。</p>
</li>
<li><p>(7) 片偏移：占13位，用来指明某数据被分片后，分片部分相对于开头的偏移量。</p>
</li>
</ul>
<blockquote>
<p>tips:值得注意的是，分片后除开最后一个切片外，所有切片的长度一定是一个8字节的整数倍。</p>
</blockquote>
<ul>
<li><p>(8) 生存时间：占8位，用来防止数据在网络中无限制的兜圈，最初设计为按时间计数(比如时间到0则丢弃),现代为按次数减少。</p>
</li>
<li><p>(9) 协议:占8位，用来指明IP层应该上交给什么协议进行处理。</p>
</li>
<li><p>(10) 首部检验和：16位，用来检测首部是否发送变化，并使用反码检验，计算后为0，则没有发生变化。</p>
</li>
<li><p>(11) 源地址，占32位，发送IP数据报的主机IP地址。</p>
</li>
<li><p>(12) 目的地址，占32位。接收IP数据报的主机IP地址。</p>
</li>
</ul>
<p>IP数据报首部还有可变部分，从1字节到40字节不等，目的为增加IP数据的功能。</p>
<blockquote>
<p>值得注意的是，这些是IPv4的部分，例如IPv6有进行删改。</p>
</blockquote>
<hr>
<h2 id="5-IP层转发分组的过程"><a href="#5-IP层转发分组的过程" class="headerlink" title="5.IP层转发分组的过程"></a>5.IP层转发分组的过程</h2><p>简介：分组在互联网中传送和转发基于分组首部的目的地址，因此这种转发表被称为基于终点转发。</p>
<ol>
<li>大体过程：</li>
</ol>
<ul>
<li>1.目的主机首先会确认是否在本网络上，如果在则直接交付，如果不再，则传递给路由器间接交付。</li>
<li>2.路由器收到数据后会将链路层的数据上交给网络层软件，网络层会根据IP地址利用转发表生成mac地址(使用ARP协议)，然后递交给链路层的帧首部MAC,由次跳转到下一个路由器的MAC地址。</li>
</ul>
<p>tips:指定注意的是，路由器并不是按照整个IP地址进行运算，而是按照IP的网络前缀进行查找，因此查找转发表的过程就是寻找前缀匹配的过程。</p>
<ol start="2">
<li><p>最长前缀匹配：有些地址采用了路由聚合，使用最长前缀匹配可以提高效率。</p>
<blockquote>
<p>tips:关于特定主机路由和默认路由，主机路由为指定路由器进，默认路由器为必须按照指定路由处理。</p>
</blockquote>
</li>
<li><p>分组转发的特点:</p>
</li>
</ol>
<ul>
<li>1.提取出收到分组的目的地址。</li>
<li>2.有特定主机路由写特定主机，否则按照最长前缀匹配。</li>
<li>3.子网掩码与目标IP地址and运算</li>
<li>4.如果有默认路由，则指明默认路由的端口，否则报错。</li>
</ul>
<ol start="4">
<li>二叉线索查表转发表：用于二叉线索(一种特殊结构的数),按照层次进行数据查找。<blockquote>
<p>tips；还配合压缩技术进行。</p>
</blockquote>
</li>
</ol>
<hr>
<h2 id="6-网际控制报文协议ICMP-Internet-Control-Message-Protocol"><a href="#6-网际控制报文协议ICMP-Internet-Control-Message-Protocol" class="headerlink" title="6.网际控制报文协议ICMP(Internet Control Message Protocol)"></a>6.网际控制报文协议ICMP(Internet Control Message Protocol)</h2><p>简介:分为两种1.差错询问报文和询问报文</p>
<ol>
<li>差错询问报文共四种</li>
</ol>
<ul>
<li>1.终点不可达:无法交付</li>
<li>2.时间超过:数据报生成时间为0时，会被路由器丢弃</li>
<li>3.参数问题:首部字段不正确</li>
<li>4.改变路由(重定向):寻找新路由（找更好的路由）</li>
</ul>
<ol start="2">
<li>无法使用ICMP的情况</li>
</ol>
<ul>
<li>1.ICMP错误报告</li>
<li>2.一个分片数据后续的分片</li>
<li>3.多播地址的数据报</li>
<li>4.目的地址为特殊地址</li>
</ul>
<ol start="3">
<li>询问报文</li>
</ol>
<ul>
<li>1.会送请求或者回答回送</li>
<li>2.时间戳请求或者时间戳回答<blockquote>
<p>tips:ICMP的一个重要应用就是ping(packet Internet Grouper),用来探测连通性，ping是应用层直接使用网络的一个例子。</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="7-IPv6"><a href="#7-IPv6" class="headerlink" title="7.IPv6"></a>7.IPv6</h2><p>简介：IPv6仍然支持无连接传送，并将协议数据单元PDU称为分组(packet),而不是数据报(datagram).</p>
<ol>
<li>基本首部</li>
</ol>
<ul>
<li>1.版本：占4位，指明了协议版本。IPv6为6.</li>
<li>2.通信量类：占8位，区分不同的数据报类别和优先级，与IPv4区别服务类似。</li>
<li>3.流标号：占20位，资源预分配机制，&#x3D;。<blockquote>
<p>tips：流，互联网上特定源点到特定终点(单播或者多播)的一系列数据报(例如实时音频或者视频传输),而这个”流”经过的路由器都保证指明的服务质量。</p>
</blockquote>
</li>
<li>4.有效荷载长度:占16位，指明IPv6除基本首部之外的字节数。</li>
<li>5.下一个首部：相当于IPv4的扩展首部。</li>
<li>6.跳转限制：每经过一个路由器限制次数便-1.</li>
<li>7.源地址，128位，数据报发送端的IP地址。</li>
<li>8.目的地址，128位，数据报目的地的IP地址。</li>
</ul>
<blockquote>
<p>tips:IPv6将主机和路由器均称为节点。</p>
</blockquote>
<ol start="2">
<li>IPv6地址</li>
</ol>
<ul>
<li>1.单播:传统的点对点通信。</li>
<li>2.多播：一对多通信，值得注意的是，IPv6将广播作为多播的一个特例。</li>
<li>3.任播：终点为一组计算机，只交付给这组中的一个。</li>
</ul>
<ol start="3">
<li><p>计法：冒号16进制计法。并进行零压缩。<br>地址分类：1.未指明地址。2.环回地址。3.多播地址。4.本地站点单播地址。5.本地链路单播地址。6.全球单播地址。</p>
</li>
<li><p>IPv4到IPv6的过度</p>
</li>
</ol>
<ul>
<li><ol>
<li>双协议栈，即同时使用IPv4到IPv6的主机(或路由器)。</li>
</ol>
</li>
<li><ol start="2">
<li>隧道技术：一种包装技术，比如将IPv6包装成Ipv4</li>
</ol>
</li>
</ul>
<ol start="4">
<li>ICMPv6:面向报文的协议，主要利用报文进行差错报告，获取信息，探测邻站和管理通信。</li>
</ol>
<hr>
<h2 id="8-互联网的路由选择协议"><a href="#8-互联网的路由选择协议" class="headerlink" title="8.互联网的路由选择协议"></a>8.互联网的路由选择协议</h2><ol>
<li>路由协议的核心是路由算法<br>算法必须具备的一些特点：</li>
</ol>
<ul>
<li>1.正确和完整的。</li>
<li>2.计算上简单</li>
<li>3.稳定性</li>
<li>4.公平的</li>
<li>5.最佳的</li>
</ul>
<p>值得主要注意的是，路由选择策略分为静态路由选择策略和动态路由选择策略，<br>静态路由选择策略称为非自适应路由选择，虽然简单开销小，但是无法适应网络状态的变化。<br>动态路由选择策略又称自适应路由选择，能够较好的适应网络状态的变化。</p>
<ol start="2">
<li>多层次的路由选择协议：整个互联网被划分为较小的自治系统(autonomous system)AS。</li>
</ol>
<p>(1)内部网关协议(IGP Interior Gataway Protocol):一个自治系统内部使用的路由选择协议。  </p>
<p>(2)外部网关协议(EGP):用于处于两个不同内部网关协议AS的路由选择，即连接不同内部网关协议的协议。</p>
<blockquote>
<p>tips:自治系统之间的路由选择称为域间路由选择。</p>
</blockquote>
<blockquote>
<p>tips2:自治系统内部的路由选择叫做域内路由选择。</p>
</blockquote>
<ol start="3">
<li>内部网关协议之RIP协议(Routing Information Protocal):基于距离的向量路由选择协议。</li>
</ol>
<ul>
<li><p>1.RIP的距离称为跳数，每经过一个网络，跳数+1，到达16即丢弃，RIP仅适用于小型互联网。</p>
</li>
<li><p>2.RIP协议的特点：</p>
<ul>
<li>1.仅交换相邻路由器交换信息。</li>
<li>2.交换的信息为当前本路由器所知道的所有信息</li>
<li>3.固定的时间间隔交换信息。<blockquote>
<p>tips:距离向量算法：找出每个目的的网络最短距离。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>tips2:这种算法的缺点是坏消息传的慢</p>
</blockquote>
<ol start="4">
<li>内部网关协议之OSPF(Open Short Path First),最短路径优先使用了Dijkstra的最短路径算法SPF。</li>
</ol>
<ul>
<li>1.主要特征为使用链路状态协议。</li>
<li>2.主要特点为：<ul>
<li>1.向本自治系统的所有路由器发送信息，这里使用的泛洪法：路由器通过所有输出端口向所有相邻的路由器发送信息。</li>
<li>2.发送的信息为本路由器和相邻的路由器的链路状态。</li>
<li>3.当链路状态发生变化或者隔一段时间(如30分钟),路由器向所有的路由器采用泛洪法发送信息。</li>
</ul>
</li>
</ul>
<blockquote>
<p>tips:RIP和OSPF的重要区别在于OSPF一个自治系统内的每一个路由器都能够构建出本自治区的拓扑网络，而RIP不知道，并且只有到达了下一个路由器才知道下一条该如何走。</p>
</blockquote>
<blockquote>
<p>tips2:值得注意的是，OSPF能够对链路状态数据库进行较快的更新，使得各个路由器能够及时更新路由表，OSPF的更新过程收敛得快是重要优点。</p>
</blockquote>
<ul>
<li><p>3.区域划分:为了使得OSPF能够局限于某个区域而不是整个AS进而减少通信量，OSFP使用区域划分，上层区域也叫做主干区域(即与其他AS相连的区域)，而其他区域被称为区域边界路由器。</p>
<blockquote>
<p>tips:主干区域的路由器被称为主干路由器，而主干区域与其他区域相连的路由器被称为自治系统边界路由器。</p>
</blockquote>
</li>
<li><p>4.OSPF五种分组类型:</p>
<ul>
<li>1.问候(Hello)分组:用于维持和发现邻站的可达性。</li>
<li>2.数据库描述(Database Description)分组:用于给邻站描述自己链路状态的数据库的信息摘要。</li>
<li>3.链路状态请求(Link State Request):向对方请求发送某些链路状态项目的详细信息。</li>
<li>4.链路更新状态：用泛洪法对全网更新链路状态信息。(核心部分)</li>
<li>5.链路确认状态(Link State Acknowledgment)分组:对链路的更新分组进行确认。<blockquote>
<p>tips：值得注意的是，除开问候分组的其他分组作用均是用于链路状态数据库的同步，此处同步的意思是不同路由器的链路状态数据库的内容是一样的，两个同步的路由器叫做”完全邻接的”。最后，不完全邻接的路由器表明物理上相邻但链路数据库并不一致。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<ol start="5">
<li>外部网关协议BGP(边界网关协议)</li>
</ol>
<ul>
<li><p>1.关于eBGP和iBGP,eGBP指两个边界路由器之间建立的连接，而iBGP指AS内部传递的BGP报文，</p>
<blockquote>
<p>tips:值得注意的是，这些报文都使用TCP协议进行传输。</p>
</blockquote>
</li>
<li><p>2.BGP路由格式:”前缀,BGP属性”.</p>
<blockquote>
<p>tips:前缀,即BGP路由的终点。</p>
</blockquote>
</li>
<li><p>3.BGP路由选择</p>
<ul>
<li>1.本地偏好值最高的路由优先选择。</li>
<li>2.选择具有AS跳数最少的路由</li>
<li>3.使用热土豆路由选择算法</li>
</ul>
</li>
<li><p>4.BGP四种报文</p>
<ul>
<li>1.Open打开报文:用来与BGP连接建立对等端关系。</li>
<li>2.Update更新报文：用来通告某一路由的信息，以及列出要撤销的路由。</li>
<li>3.KeepAlive保活报文:用来周期性的证实和对等端的连通性。</li>
<li>4.NotIfICation通知报文:用来发送检测到的差错。</li>
</ul>
</li>
</ul>
<ol start="6">
<li>三种不同的自治系统：</li>
</ol>
<ul>
<li>1.末梢AS(stub AS)</li>
<li>2.穿越AS(transit AS)</li>
<li>3.对等AS(peering AS)</li>
</ul>
<hr>
<h2 id="9-路由器的构成"><a href="#9-路由器的构成" class="headerlink" title="9.路由器的构成"></a>9.路由器的构成</h2><ol>
<li><p>路由器：具有多种输入端口和输出端口的专用计算机，任务为转发分组。</p>
</li>
<li><p>路由器的结构可以被划分为两部分:1.控制部分(或者控制层面，路由选择部分)。2.数据层面。</p>
</li>
</ol>
<ul>
<li>1.控制部分：核心部分是路由选择处理机，处理机根据选定的路由选择协议构造出路由表，并定期交换信息维护路由表。</li>
<li>2.数据层面:分为三部分1.交换结构。2.输入端口。3.输出端口(注意，这里的端口是硬件)。交换结构根据转发表对分组进行处理。<blockquote>
<p>tips:交换结构可以看成在路由器中的网络。</p>
</blockquote>
</li>
</ul>
<ol start="3">
<li><p>转发和路由选择的区别：转发是指路由器根据转发表转发数据，仅仅涉及一个路由器。路由选择则涉及许多路由器。</p>
</li>
<li><p>路由表和转发表：路由表一般包涵目的地址的IP地址表示。转发表由路由表得出，其中包涵IP与MAC地址的映射关系。</p>
<blockquote>
<p>tips:路由器转发速度称为线速。</p>
</blockquote>
</li>
</ol>
<hr>
<h2 id="10-IP多播"><a href="#10-IP多播" class="headerlink" title="10.IP多播"></a>10.IP多播</h2><ol>
<li><p>IP多播利用网际管理协议IGMP(Internet Group Management Prootocol)<br>,IP多播需要分组，需要借助多播路由器，并且可以由没有加入多播组的主机发出。</p>
</li>
<li><p>IGMP工作两个阶段：</p>
</li>
</ol>
<ul>
<li>1.主机加入新的多播组时，该主机向多播组的多播地址发送一条IGMP报文。</li>
<li>2.组成员是动态的，多播路由器需要周期性的探测本地局域网的主机以便知道这些主机是否还继续是组的成员。</li>
</ul>
<h2 id="11-虚拟专用网VPN和网络地址转换NAT"><a href="#11-虚拟专用网VPN和网络地址转换NAT" class="headerlink" title="11.虚拟专用网VPN和网络地址转换NAT"></a>11.虚拟专用网VPN和网络地址转换NAT</h2><ol>
<li><p>专用地址，用于机构内部通信，不能与互联网上的主机通信。在互联网的所有路由器，对目的地址是专用地址的数据报一律不转发。</p>
<blockquote>
<p>tips:对于专用网络，可以在内部有一定自由的IP地址自动分配，不过在与外界连接时，需要进行IP地址转换。</p>
</blockquote>
</li>
<li><p>虚拟专用网络VPN:公用的互联网作为本地机构各个专用网之间的通信载体。</p>
</li>
<li><p>外联网(Extranet VPN):即某个机构的VPN需要外部的机构参与(即相连)。</p>
</li>
<li><p>NAT：安装在互联网路由器上的软件，这种路由器叫做NAT路由器，作用为将专用网的IP地址转化为互联网的IP地址。</p>
</li>
<li><p>多协议标签交换MPLS(MultiProtocol Lable Switching):<br>使用面向连接技术，使每个分组携带的一个叫作标签(label)的小整数，进而用分组提高交换机(即标签交换路由器)的转发分组速率。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/21/Internet/6.%E5%BA%94%E7%94%A8%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuanSchuan">
      <meta itemprop="description" content="既然选择远方，便不顾风雨亦兼程">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="川山">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/21/Internet/6.%E5%BA%94%E7%94%A8%E5%B1%82/" class="post-title-link" itemprop="url">6.应用层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-21 11:33:44" itemprop="dateCreated datePublished" datetime="2022-10-21T11:33:44+08:00">2022-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-24 09:41:15" itemprop="dateModified" datetime="2022-10-24T09:41:15+08:00">2022-10-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-应用层简介"><a href="#1-应用层简介" class="headerlink" title="1.应用层简介"></a>1.应用层简介</h2><ol>
<li>应用层主要为了解决某一类问题，而这些问题的解决必须通过位于不同主机中的多个应用进程之间的通信和协同工作来完成。</li>
<li>许多应用层的协议基于客户端服务器方式，即P2P的对等通信方式。值得注意的是，客户和服务器都是指涉及的两个应用进程。主要特征就是客户是服务请求方，服务器是服务提供方。</li>
</ol>
<hr>
<h2 id="2-DNS域名系统"><a href="#2-DNS域名系统" class="headerlink" title="2.DNS域名系统"></a>2.DNS域名系统</h2><ol>
<li><p>DNS作用:提供名字与IP地址的转换。</p>
<blockquote>
<p>tips:域名只是逻辑概念，与计算机所在的地理位置无关。</p>
</blockquote>
</li>
<li><p>DNS的系统：采用联机分布式数据库系统。DNS的名字大多在本地进行解析，少量需要在互联网通信。</p>
</li>
<li><p>DNS采用层次树的命名方法。任何一个连接在互联网的主机或者路由器，都有唯一的层次结构名字，即域名。域名多级，分别为顶级域名(.com等),二级域名，三级域名。</p>
<blockquote>
<p>tips:域指名字空间中一个可被管理的划分。域还可以继续划分为子域。</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>tips2:顶级域名分为:国家顶级域名，通用顶级域名，基础结构顶级域名。值得注意的式，我国二级域名划分为类别域名(比如.ac为科研机构)和行政区域名(比如北京为bj)。</p>
</blockquote>
<ol start="4">
<li><p>域名服务器:域名服务器一个服务器所管辖的范围称为区，因此DNS服务器的管辖范围不是域而是区。</p>
<blockquote>
<p>tips；为了保证DNS工作不会因为一个服务器故障而中断，DNS域名服务器会把数据复制到几个域名服务器保存。其中一个为主域名服务器，其他为辅助域名服务器。</p>
</blockquote>
</li>
<li><p>DNS查询步骤：</p>
</li>
</ol>
<ul>
<li>1.主机先向本地域名服务器查询，本地服务器使用递归查询。<br>(没找到)</li>
<li>2.本地域名服务器采用迭代查询，它向根域名服务器查询。</li>
<li>3.根域名服务器告诉本地域名服务器下一次应查询的顶级域名服务器IP地址。</li>
<li>4.根域名服务器告诉本地域名服务器下一次应该查询的权限域名服务器IP地址。</li>
<li>5.本地域名服务器向指定权限域名服务器查询。</li>
<li>6.权限域名服务器告诉本地域名服务器，所查询的主机IP地址。</li>
<li>7.本地域名服务将查询结果告诉主机。</li>
</ul>
<hr>
<h2 id="3-文件传送协议FTP-file-transfer-protocol"><a href="#3-文件传送协议FTP-file-transfer-protocol" class="headerlink" title="3.文件传送协议FTP(file transfer protocol)"></a>3.文件传送协议FTP(file transfer protocol)</h2><ol>
<li>FTP基本工作步骤：</li>
</ol>
<ul>
<li>1.工作步骤：(1)打开熟知端口，使得客户进程能够连接。(2)等待客户进程发出连接请求。(3)启动从属进程处理客户进程的请求，并在处理完后关闭子进程。从属进程在运行期间根据需要还可以创建其他子进程。(4)回到等待状态。主进程与从属进程的处理是并行发生的。</li>
</ul>
<ol start="2">
<li><p>服务器的从属进程：控制进程和数据传送进程。<br>控制连接主要用于主要用于发送服务端的控制进程。在连接后，控制连接会创建数据传送进程和数据连接用于传送数据。</p>
</li>
<li><p>NFS网络文件系统：NFS允许应用进程打开一个远地文件，并能在该文件的某一个特定位置上开始读写数据，而不需要复制整个文件。</p>
</li>
</ol>
<hr>
<h2 id="4-简单文件传送协议：TFTP-Trivial-File-Transfer-Protocol"><a href="#4-简单文件传送协议：TFTP-Trivial-File-Transfer-Protocol" class="headerlink" title="4.简单文件传送协议：TFTP(Trivial File Transfer Protocol)"></a>4.简单文件传送协议：TFTP(Trivial File Transfer Protocol)</h2><ol>
<li>使用UDP数据报进行通讯。</li>
<li>主要特点</li>
</ol>
<ul>
<li>1.每次数据报大小为512.最后一次不足512.</li>
<li>2.按序号编号，从1开始。</li>
<li>3.支持ASCII或二进制传送</li>
<li>4.对文件进行读写</li>
<li>5.使用很简单的首部。</li>
</ul>
<hr>
<h2 id="5-远程终端协议TELNET"><a href="#5-远程终端协议TELNET" class="headerlink" title="5.远程终端协议TELNET"></a>5.远程终端协议TELNET</h2><ol>
<li>作用：主要使用TCP远程登陆，因此也称终端仿真协议，现在已经很少使用</li>
</ol>
<hr>
<h2 id="6-万维网WWW-World-Wide-Web"><a href="#6-万维网WWW-World-Wide-Web" class="headerlink" title="6.万维网WWW(World Wide Web)"></a>6.万维网WWW(World Wide Web)</h2><ol>
<li><p>简介：大规模，联机式的信息储存场所。万维网的链接方法能够很方便的从互联网上一个站点访问另一个站点。WWW是分布式的超媒体系统，是超文本系统的扩充。</p>
</li>
<li><p>链接，即超链接：在使用文档后即可从本文档链接到其他可能相隔很远的文档。</p>
</li>
<li><p>万维网工作：万维网以客户服务器方式工作，当客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档。</p>
</li>
</ol>
<blockquote>
<p>tip1:比如浏览器就是用户主机上的万维网客户程序。万维网文档所驻留的主机则运行服务器程序，而这台主机称为万维网服务器。</p>
</blockquote>
<ol start="4">
<li>统一资源定位符URL(Uniform resource locator):用于标志万维网的各种文档，并使得每一个文档都在整个互联网的服务范围内具有唯一标识符URL.<br>主要格式为:协议:&#x2F;&#x2F;主机名(主机所在域名):&#x2F;端口(通常省略，使用默认端口名)&#x2F;路径</li>
</ol>
<blockquote>
<p>tips:URL相当于文件名在网络范围的扩展，因此URL是与互联网相连的机器上的任何可访问的指针。</p>
</blockquote>
<ol start="5">
<li><p>超文本传输协议HTTP(HyperText Markup Language):用于万维网客户程序与万维网服务器程序之间的交互协议。</p>
</li>
<li><p>Http：使用TCP进行可靠传输，协议本身无连接，无状态。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/17/Internet/5-%E8%BF%90%E8%BE%93%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuanSchuan">
      <meta itemprop="description" content="既然选择远方，便不顾风雨亦兼程">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="川山">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/17/Internet/5-%E8%BF%90%E8%BE%93%E5%B1%82/" class="post-title-link" itemprop="url">5.运输层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-17 08:36:14" itemprop="dateCreated datePublished" datetime="2022-10-17T08:36:14+08:00">2022-10-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-24 09:40:17" itemprop="dateModified" datetime="2022-10-24T09:40:17+08:00">2022-10-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-运输层协议概述"><a href="#1-运输层协议概述" class="headerlink" title="1.运输层协议概述"></a>1.运输层协议概述</h2><ol>
<li>运输粗的分用和复用：</li>
</ol>
<ul>
<li>1.复用指不同应用程序使用同一个运输层协议</li>
<li>2.接收方在剥去报文的首部后能够把这些数据正确交付给目的应用进程。<blockquote>
<p>tips:值得注意的是，网络层为主机之间的通信提供服务。而运输层在网络层的基础上，为应用进程之间通讯提供服务。</p>
</blockquote>
</li>
</ul>
<ol start="2">
<li>运输层协议：两个运输实体之间提供端到端的逻辑通信服务。这些服务会因为运输层使用的不同协议出现很大的不同。</li>
</ol>
<ul>
<li>1.UDP:无连接，尽最大可能交付数据。</li>
<li>2.TCP:面向连接，尽管网络不可靠，但由TCP提供的逻辑通信信道相当于一条全双工的可靠信道。</li>
</ul>
<hr>
<h2 id="2-运输层的两个主要协议"><a href="#2-运输层的两个主要协议" class="headerlink" title="2.运输层的两个主要协议"></a>2.运输层的两个主要协议</h2><ol>
<li>两个协议分别为:1.UDP(User Datagram Protocol).2.TCP(Transmission Control Protocol)<blockquote>
<p>tips:运输层的数据单位叫做运输协议数据单元TPDU(Transport Protocol Data Unit)</p>
</blockquote>
</li>
</ol>
<ul>
<li>1.UDP:不需要建立连接,收到报文不需要确认，不提供可靠交付。</li>
<li>2.TCP:面向连接的服务，传输数据前必须建立连接，结束后要释放连接，并且不提供广播和多播服务，因为TCP的可靠性，所以会额外增加许多开销。</li>
</ul>
<ol start="2">
<li>端口号:一台主机的多个进程可以同时进行通信，为了使得相应进程能够获取到对应的数据，因此给每种进程划分出端口号，相应的进程的收发数据就从这个端口进行。<blockquote>
<p>tips；值得注意的是，软件和硬件的端口不是同一种，软件的端口号是指分配的一块地址的名字，硬件的端口号是指连接硬件的接口，</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>tips2:目前1~1023端口被花费给一些知名的程序，这类端口被称为登记端口号。客户端使用的端口号称为短暂端口号。</p>
</blockquote>
<ol start="3">
<li>用户数据报协议(UDP)特点:</li>
</ol>
<ul>
<li>1.无连接。</li>
<li>2.尽最大努力交付。</li>
<li>3.面向报文。</li>
<li>4.没有拥塞控制。</li>
<li>5.UDP支持一对一，一对多，多对一和多对多通信。</li>
<li>6.首部开销小。</li>
</ul>
<ol start="4">
<li>UDP首部格式:</li>
</ol>
<ul>
<li>1.源端口</li>
<li>2.目的端口</li>
<li>3.长度</li>
<li>4.检验和</li>
</ul>
<ol start="5">
<li>传输控制协议TCP的特点：</li>
</ol>
<ul>
<li>1.TCP面向连接，即需要建立连接。</li>
<li>2.只能点对点通信。</li>
<li>3.提供可靠交付，即TCP连接的数据无差错，不丢失，不重复。</li>
<li>4.面向字节流，即TCP仅仅将数据看成一串无结构的字节流。<blockquote>
<p>tips:TCP建立的是虚连接，即逻辑连接。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>tips2: TCP连接的端口为套接字(IP:端口)</p>
</blockquote>
<ol start="6">
<li>可靠传输的工作原理</li>
</ol>
<ul>
<li><p>1.需要解决的问题：1.传输信道不产生差错。2.无论发送方的数据多快，接收方都来得及接收。</p>
</li>
<li><p>2.解决方法：</p>
<ul>
<li><p>1.产生差错：使用超时重传，每次发送完一个分组时，设置一个超时计时器，如果在超时计时器过期之前收到确认，就撤销超时计时器，否则重新发送分组。</p>
</li>
<li><p>2.停止等待协议：即每次发送完一个分组就等待发送，等待对方确认，收到确认后再发送下一个分组。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>tips:超时计数器需要注意的三点：1.必须暂时保留已发送的分组副本(用于超时重发)。2.分租和确认分组都需要进行编号。3.重传计时器的时间需要比数据接收的时间长一些，因为需要确认返回的时间。</p>
</blockquote>
<ul>
<li><p>3.确认丢失和确认迟到：用于接收方返回给发送方一些报文。</p>
</li>
<li><p>4.信道利用率：停止等待协议优点是简单，但信道利用率太低，因此当使用流水线传输的时候，就需要使用ARQ协议和滑动窗口协议。<br>ARQ协议：发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。<br>滑动窗口：三个指针，1.指向已发送已确认数据的数据的结尾+2.指向已发送但未确认数据的结尾+3.指向允许发送但尚未发送的结尾+剩下的为不允许发送。</p>
<blockquote>
<p>tips：之所以使用滑动窗口的原因在于控制发送发速率使得接收方能够接收。</p>
</blockquote>
</li>
</ul>
<ol start="7">
<li>TCP报文段的首部格式：</li>
</ol>
<ul>
<li>1.源端口和目的端口:各占2字节。</li>
<li>2.序号:4字节。</li>
<li>3.确认号：4字节，期望收到对方下一个报文的第一个数据字节的序号。<blockquote>
<p>tips:若确认号为n，那么说明序号n-1为止的所有数据都已经确认收到。</p>
</blockquote>
</li>
<li>4.数据偏移：占4位，注意是位不是字节。</li>
<li>5.保留:6位。</li>
<li>6.紧急URG(URgent):紧急报文，尽快传送，不要按照原来的排队顺序传送。URG&#x3D;1时有效。</li>
<li>7.确认号ACK:ack&#x3D;1时有效。</li>
<li>8.推送(PuSH):立即发送，不要等到缓存满。</li>
<li>9.复位：重置位。</li>
<li>10.同步：同步序号</li>
<li>11.终止：用于释放一个连接</li>
<li>12.窗口：2字节，指发送本报文段一方的接收窗口。</li>
<li>13.检验和：2字节，</li>
<li>14.紧急指针：2字节。指出紧急报文的字节数</li>
<li>15.选项：长度可变，最长40字节。</li>
</ul>
<ol start="8">
<li>TCP的流量控制</li>
</ol>
<ul>
<li>1.利用滑动窗口实现流量控制，而流量控制就是让发送方的发送速率不要太快，使得接收方能够接收。</li>
<li>2.TCP窗口的单位是字节，不是报文段。</li>
</ul>
<ol start="9">
<li>TCP的拥塞控制</li>
</ol>
<ul>
<li>1.介绍：计算机网络中的链路容量(即带宽)，交换节点的缓存和处理机等都是网络资源。若在某一段时间内，若对网络中的某一项资源的需求超过了该资源所能提供的部分，网络性能变坏就称为拥塞(congestion)。即∑对资源的需求&gt;可用资源</li>
</ul>
<p>值得注意是，单纯的提高某部分的网络性能并不能很好的解决拥塞，反而会造成严重的网络资源浪费，解决方法为使用拥塞控制：防止过多的数据注入到网络中，防止网络中的链路或者路由器不至于过载。</p>
<ul>
<li>2.拥塞控制的4种算法：1.慢开始。2.拥塞避免。3.快重传。4.快恢复。<ul>
<li>1.慢开始和拥塞避免(一般一起使用)。慢开始：即注入网络的数据字节由小逐渐变大，也就是逐渐增大拥塞窗口的数值。</li>
<li>2.拥塞避免：即避免拥塞窗口增长的过于缓慢。</li>
<li>3.快重传和快恢复：快重传：快重传首先不要求接收方等待自己发送数据才捎带确认，而是立即发送确认，使用快重传能够让对方早知道发生了个别报文段的丢失。</li>
<li>4.快恢复：对于丢失的个别报文段，执行快恢复算法。</li>
</ul>
</li>
</ul>
<ol start="10">
<li><p>流量控制和拥塞控制的区别：1.流量控制减少发送量的原因是接收方来不及接收。拥塞控制的原因在于穿过通道被堵塞，导致的包括超时重传等错误，而接收方有能力接收目前网络中发送的数据。</p>
<blockquote>
<p>tips:死锁，即拥塞状态导致的网络吞量变成了0。</p>
</blockquote>
</li>
<li><p>主动列队管理(AQM)</p>
</li>
</ol>
<ul>
<li>1.主要用于防止网络出现全局同步的现象。</li>
</ul>
<ol start="12">
<li>TCP运输连接管理</li>
</ol>
<ul>
<li>1.TCP的运输连接的三个阶段：1.连接建立。2.数据传送。3.连接释放。</li>
<li>2.TCP连接建立：1A向B发出请求连接报文段。2.B收到后，如果同意建立连接，则向A发送确认。3.A收到B的确认后，再向B发送收到确认。这是三次握手，四次魔兽是指B发送给A的报文可以拆分成确认报文和同步报文。</li>
<li>3.TCP释放：1.A向B发送释放报文段，停止发送数据，关闭TCP连接。2.B收到释放报文的报文段后发出确认，B层TCP通知应用层，然后TCP连接处于半关闭状态。如果B没有要向A发送的数据，即重复A的行为即可。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/13/mysql/mysql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuanSchuan">
      <meta itemprop="description" content="既然选择远方，便不顾风雨亦兼程">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="川山">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/13/mysql/mysql/" class="post-title-link" itemprop="url">mysql</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-13 13:29:42" itemprop="dateCreated datePublished" datetime="2022-10-13T13:29:42+08:00">2022-10-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-14 16:11:23" itemprop="dateModified" datetime="2022-10-14T16:11:23+08:00">2022-10-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>注意：char类型的都需要加’’.中英文都需要。只有关键字，名字不需要。</p>
<p>关于数据库</p>
<p>（1）不区分大小写，SELECT，SElect,select是一样的。</p>
<hr>
<h2 id="1-数据库包涵以下4部分"><a href="#1-数据库包涵以下4部分" class="headerlink" title="1. 数据库包涵以下4部分"></a>1. 数据库包涵以下4部分</h2><ol>
<li>数据定义语言DDL：用来创建删除数据库以及表等对象:DROP,CREATE,ALTER.</li>
<li>数据操作语言DML:用来变更表中记录。SELECT,INSERT,UPDATA,DELETE.</li>
<li>数据查询语言DQL:用来查询表中的记录，主要包涵SELECT命令，来查询表中数据。</li>
<li>数据控制语言DCL:用来确认或者取消对数据库中的数据进行的变更。除此之外，还可以对数据库中的用户，设定权限。grant赋予操作权限,revoke取消操作权限,commit确认数据变更,rollback.取消数据变更。</li>
</ol>
<hr>
<h2 id="2-数据库操作"><a href="#2-数据库操作" class="headerlink" title="2. 数据库操作:"></a>2. 数据库操作:</h2><p>[]为可选符号，意思是可有可无。如果没有[]则查询所有数据库，有like用来匹配包涵此关键字的数据库<br>   &lt;&gt;必选<br>   {}选一个</p>
<ol>
<li><p>查看数据库:show database [like ‘name’];</p>
</li>
<li><p>创建数据库:create database [if not exists] &lt; name&gt;</p>
<p>[[default] character set&lt;字符集名字&gt;] 用于指定字符集，如果没有制定字符集，则使用系统默认字符集。</p>
<p>[[default]collate&lt;校对规则名&gt;]用于指定字符集的默认校对规则</p>
<p>[if not exists]中的意思是如果不存在就创建。</p>
</li>
<li><p>修改数据库:alter database [name]   用于当前数据库可以不写</p>
<p>[[default] character set&lt;字符集名字&gt;]  ：修改字符集</p>
<p>[[default]collate&lt;校对规则名&gt;]用于指定字符集的默认校对规则</p>
</li>
<li><p>删除数据库:drop database [if exists] &lt; name &gt;;</p>
</li>
<li><p>选择数据库 use &lt; name&gt;选择使用哪个数据库</p>
</li>
</ol>
<hr>
<h2 id="3-数据库设计步骤：-1-需求分析。-2-概要设计。-3-逻辑设计，详细设计。-4-代码编写。-5-软件测试。-6-安装部署。"><a href="#3-数据库设计步骤：-1-需求分析。-2-概要设计。-3-逻辑设计，详细设计。-4-代码编写。-5-软件测试。-6-安装部署。" class="headerlink" title="3. 数据库设计步骤：(1)需求分析。(2)概要设计。(3)逻辑设计，详细设计。(4)代码编写。(5)软件测试。(6)安装部署。"></a>3. 数据库设计步骤：(1)需求分析。(2)概要设计。(3)逻辑设计，详细设计。(4)代码编写。(5)软件测试。(6)安装部署。</h2><hr>
<h2 id="4-数据库数值类型："><a href="#4-数据库数值类型：" class="headerlink" title="4. 数据库数值类型："></a>4. 数据库数值类型：</h2><ol>
<li>整形:</li>
</ol>
<ul>
<li><ol>
<li>tinyint(1字节)</li>
</ol>
</li>
<li><ol start="2">
<li>smallint(2)</li>
</ol>
</li>
<li><ol start="3">
<li>mediumint(3)</li>
</ol>
</li>
<li><ol start="4">
<li>int(4)</li>
</ol>
</li>
<li><ol start="5">
<li>bigint(5)</li>
</ol>
</li>
</ul>
<p>  浮点类型：</p>
<ul>
<li><ol>
<li>float(4)</li>
</ol>
</li>
<li><ol start="2">
<li>double(8)</li>
</ol>
</li>
</ul>
<p>  定点数类型为:</p>
<ul>
<li><ol>
<li>decimal(M,D),(M+2个字节)</li>
</ol>
</li>
</ul>
<p>   time：HH:MM:SS</p>
<ol start="2">
<li>时间日期类型:</li>
</ol>
<ul>
<li><ol>
<li>year(1)</li>
</ol>
</li>
<li><ol start="2">
<li>time(3)</li>
</ol>
</li>
<li><ol start="3">
<li>data(3)</li>
</ol>
</li>
<li><ol start="4">
<li>datetime(8)</li>
</ol>
</li>
<li><ol start="5">
<li>timestamp(4)</li>
</ol>
</li>
</ul>
<blockquote>
<p>tips:char和varchar区别为char是固定长度比如char(4),最大包涵4，varchar为可变。</p>
</blockquote>
<ol start="3">
<li>字符串类型:</li>
</ol>
<ul>
<li><ol>
<li>char（M.1&lt;&#x3D;M&lt;&#x3D;255）</li>
</ol>
</li>
<li><ol start="2">
<li>varchar(L+1,L&lt;&#x3D;M)</li>
</ol>
</li>
<li><ol start="3">
<li>varbinary</li>
</ol>
</li>
<li><ol start="4">
<li>blog</li>
</ol>
</li>
<li><ol start="5">
<li>text</li>
</ol>
</li>
<li><ol start="6">
<li>enum</li>
</ol>
</li>
<li><ol start="7">
<li>set</li>
</ol>
</li>
</ul>
<ol start="4">
<li>二进制类型:</li>
</ol>
<ul>
<li><ol>
<li>bit</li>
</ol>
</li>
<li><ol start="2">
<li>binary</li>
</ol>
</li>
<li><ol start="3">
<li>tinyblog</li>
</ol>
</li>
<li><ol start="4">
<li>blog</li>
</ol>
</li>
<li><ol start="5">
<li>dediumblog</li>
</ol>
</li>
<li><ol start="6">
<li>longblog</li>
</ol>
</li>
</ul>
<hr>
<h2 id="5-操作数据表"><a href="#5-操作数据表" class="headerlink" title="5. 操作数据表"></a>5. 操作数据表</h2><ol>
<li>创建数据表：主要由表创建定义，表选项，分区。<br>create table &lt;表名&gt;([表定义选项])[表选项] [分区选项]；</li>
</ol>
<blockquote>
<p>tips: 表定义选项：可能的约束等  </p>
</blockquote>
<p>&lt;列名1&gt;&lt;类型1&gt;[,…]&lt;列明n&gt;&lt;类型n&gt; [约束] [默认值]  </p>
<p>比如:create table tst1(t1 int(11) ,t2 char,t3 date);</p>
<ol start="2">
<li>修改数据表:alter table &lt;表名&gt;[修改选项]<br>以下为可修改可选项：</li>
</ol>
<ul>
<li><ol>
<li>添加列:add column&lt;列名&gt;&lt;类型&gt;[约束条件]</li>
</ol>
</li>
<li><ol start="2">
<li>修改列:change column&lt;旧列名&gt;&lt;新列名&gt;&lt;新增类型&gt;</li>
</ol>
</li>
<li><ol start="3">
<li>修改或删除列名默认值：alter column&lt;列名&gt;{set default&lt;默认值&gt;|drop default &lt;默认值&gt;}</li>
</ol>
</li>
<li><ol start="4">
<li>和change一样，但不可以重命名：modify column&lt;列名&gt;&lt;类型&gt;</li>
</ol>
</li>
<li><ol start="5">
<li>删除列:drop column&lt;列名&gt;，drop &lt;约束&gt; &lt;列名&gt;可以删除某字段的某个约束</li>
</ol>
</li>
<li><ol start="6">
<li>重命名表名 rename to&lt;新表名&gt;</li>
</ol>
</li>
<li><ol start="7">
<li>重新设置字符集:character set&lt;字符集名&gt;</li>
</ol>
</li>
<li><ol start="8">
<li>重新设置校对规则名:collate &lt;校对规则名&gt;</li>
</ol>
</li>
</ul>
<blockquote>
<p>tips:注意，add column&lt;列名&gt;&lt;类型&gt;[约束条件] [first]为首位添加，没有则在末尾添加，在中间添加，也就是在某字段后添加则为after &lt;存在的字段名&gt;</p>
</blockquote>
<pre><code>  比如：

  1.修改表名:alter table &lt; old name&gt; rename [to] &lt; new name&gt;。

  2.修改字段名和类型:alter table &lt;表名&gt; change&lt;旧列名&gt;&lt;新列名&gt;&lt;新类型&gt;

  3.修改类型:alter table &lt;表名&gt; modify &lt;字段名&gt;&lt;新类型&gt;

  4.删除字段名：alter table &lt;表名&gt; drop &lt;字段名&gt;
</code></pre>
<ol start="3">
<li>查看表:</li>
</ol>
<ul>
<li><ol>
<li>show create table&lt;表名&gt;[&#x2F;g],&#x2F;g或&#x2F;G可以改变展示形式，区别我不懂:查看表数据。</li>
</ol>
</li>
<li><ol start="2">
<li>describe &lt;表名&gt;或desc &lt;表名&gt;：查看表结构</li>
</ol>
</li>
</ul>
<ol start="4">
<li>删除表</li>
</ol>
<p>drop table [if exists] 表名1   [表名2,3…]。</p>
<blockquote>
<p>tips:注意要删除的表的字段为其他表外键的约束时，无法直接删除该表。有两种方法可以删除1.删除俩表。2.取消外键约束。</p>
</blockquote>
<hr>
<h2 id="6-mysql字段的约束-constraint"><a href="#6-mysql字段的约束-constraint" class="headerlink" title="6. mysql字段的约束(constraint)"></a>6. mysql字段的约束(constraint)</h2><ol>
<li>主键约束：该字段能够唯一标识表中的每条信息。只能给一个字段设置，不可以有空值。<br>创建主键:</li>
</ol>
<ul>
<li><p>(1)create table t1(id int primary key).</p>
</li>
<li><p>(2)或者在结束后使用[constraint &lt;约束名字&gt;] primary key [字段名]添加：primary key (id)</p>
</li>
</ul>
<blockquote>
<p>tips:联合主键：当需要多个字段共同担任主键时使用，且不能直接在后面添加，需要使用上述的第二种方法primary key col1[col2,col3].</p>
</blockquote>
<p>修改主键时:</p>
<ul>
<li>(1)alter table 表名{add constraint  primary key(字段名)| modify 字段名 新类型 主键}</li>
</ul>
<p>删除主键:</p>
<ul>
<li>(1)alter table 表名 drop primary key。因为主键唯一，所以不需要声明字段名。</li>
</ul>
<blockquote>
<p>tips:键自增长:必须满足以下条件(1)必须not null,(2)为整形(3)没有达到类型极限。</p>
</blockquote>
<blockquote>
<p>tips2:注意：只有主键才可以设置自增长，删除自增长需要使用modify，change等重置属性，并且主键如果有自增长就不可以删除，必须重置。</p>
</blockquote>
<blockquote>
<p>tips3:auto_increment :作用使得该字段下一条数据为上一条数据的++。注意，自增非约束，因此是写在约束后面的，比如create table name{  id int primary key au	to_increment}</p>
</blockquote>
<ol start="2">
<li>外键约束:用来确保数据一致性:<br>外键约束必要条件：</li>
</ol>
<ul>
<li><p>1.被参考的建必须是被参考表的主键。</p>
</li>
<li><p>2.建立外键的表的主键不可以建立外键。</p>
</li>
<li><p>3.被参考的主键和被建立外键的字段类型需要相同。</p>
</li>
<li><p>（1）创建外键</p>
</li>
</ul>
<blockquote>
<p>tips:外键建立条件：首先：建立外键的键必须存在，其次，参考键必须为主键。<br>在表字段创建结束后创建  </p>
</blockquote>
<p>create table 表名( id int,,constraint 外键名 foreign key(id) references 参考表名(参考表主键))</p>
<blockquote>
<p>tips:注意，创建外键需要被创建的值先存在，因此只能最后用constraint创建</p>
</blockquote>
<ul>
<li>（2）修改外键约束，注意，这里修改只可以使用add,不可以使用modify,change等。</li>
</ul>
<p>alter table 表名 add constraint 外键名 foreign key(建立外键的字段) references 参考表(参考表的主键)</p>
<ul>
<li>(3)删除外键约束</li>
</ul>
<p>alter table &lt;表名&gt; drop foreign key &lt;外键约束名&gt;</p>
<ol start="3">
<li>唯一约束：与主键相似，但只能唯一标识字段中的每一条信息。与主键区别在于可以有多个，并且可以有空值，虽然空值也只能有一个。</li>
</ol>
<ul>
<li><p>(1)创建唯一唯一约束</p>
<p>&lt;字段名&gt;&lt;数据类型&gt;unique</p>
</li>
<li><p>(2)修改唯一约束</p>
<p>alter table &lt;数据表名&gt; add constraint &lt;唯一约束名&gt; unique(&lt;列名&gt;)</p>
</li>
<li><p>(3)删除唯一约束</p>
<p>alter table&lt;表名&gt; drop index&lt;唯一约束名&gt;</p>
</li>
</ul>
<ol start="4">
<li>约束检查：用来检查表中字段值是否有效。：比如输出的年龄为负，这是无效的，可以通过约束检查来实现检验。可以通过create table或者alter table实现</li>
</ol>
<p>check(&lt;约束检查&gt;)</p>
<ul>
<li><p>(1)创建 cre	ate tabel 表名 (id int primary key,salary float,check(salary&gt;0 and salary &lt;100))</p>
</li>
<li><p>(2)修改alter table 表名 add constraint &lt;检查约束名&gt; check (&lt;检查约束&gt;)</p>
</li>
<li><p>(3)删除约束 alter table &lt;数据表名&gt; drop constraint&lt;检查约束名&gt;</p>
</li>
</ul>
<ol start="5">
<li>非空约束：表中记录不能为空，如果输入的值为空，则会报错，通过create ,alter实现。</li>
</ol>
<ul>
<li>(1）创建</li>
</ul>
<p>&lt;字段名&gt;&lt;数据类型&gt;not null;</p>
<ul>
<li>(2)修改</li>
</ul>
<p>alter table 数据表名 change column&lt;字段名&gt;&lt;字段名&gt;&lt;数据类型&gt;not null;</p>
<ul>
<li>(3)删除</li>
</ul>
<p>alter table &lt;数据表名&gt; change column&lt;字段名&gt;&lt;字段名&gt;&lt;数据类型&gt;null</p>
<ol start="6">
<li><p>默认约束，当字段不输入值时，为其自动填上一个值。</p>
<p>(1)创建</p>
<p>&lt;字段名&gt;&lt;数据类型&gt;default&lt;默认值&gt;</p>
<p>（2）修改</p>
<p>alter table &lt;数据表名&gt;change column &lt;字段名&gt;&lt;数据类型&gt;default &lt;默认值&gt;</p>
<p>CHANGE COLUMN location  location VARCHAR(50) DEFAULT ‘Shanghai</p>
<p>(3)删除默认约束</p>
<p>alter table&lt;数据表名&gt; change cloumn &lt;字段名&gt;&lt;字段名&gt;&lt;数据类型&gt; default NULL’</p>
<p>7.查看约束 show create table &lt;表名&gt;</p>
<p>8.添加备注 comment ‘备注’</p>
</li>
</ol>
<h2 id="7-操作数据表数据基本操作"><a href="#7-操作数据表数据基本操作" class="headerlink" title="7. 操作数据表数据基本操作"></a>7. 操作数据表数据基本操作</h2><ol>
<li>查询数据库<br>select {*|&lt;字段列名&gt;}  [from &lt;表1&gt;,&lt;表2&gt;… where &lt;表达式&gt; group by&lt; group by definition&gt; having&lt; expression&gt; order by&lt; order by definition&gt; limit[&lt; offset&gt;] ,[row count]]</li>
</ol>
<blockquote>
<p>tips:*|&lt;字段名&gt; *为查询全部，后面表示要查询的字段</p>
</blockquote>
<ul>
<li><ol>
<li><p>使用*,查询某表全部数据</p>
<pre><code>select * from 表名
</code></pre>
</li>
</ol>
</li>
<li><ol start="2">
<li><p>查询某表具体字段数据</p>
<pre><code>select &lt;列名&gt; from&lt;表名&gt;
</code></pre>
</li>
</ol>
</li>
<li><ol start="3">
<li><p>distinct去除重复值</p>
<pre><code>select distinct &lt;字段名&gt; from &lt;表名&gt;

当一列字段有多个值，比如年龄表(18,18,19,19,20,20,20).返回值为(18,19,20)三个，去除其他重复值。
</code></pre>
</li>
</ol>
</li>
<li><ol start="4">
<li><p>指定别名</p>
<pre><code>(1)为表指定别名&lt;表名&gt; as&lt;别名&gt;

select stu.aget from tb_student AS stu.：将tb_student 指定为stu，这个就可以直接在前面使用stu查询tb_student表的值。注意，表名+空格+别名也是可以的，只是不规范而已。

(2)为字段指定别名 &lt;字段名&gt;[as] &lt;别名&gt;

select age a from 表名，输出不是age,是a.

二者作用区别渠道，指定表名是为了能够减少表名字数。指定字段名是更改字段名的输出名字。
</code></pre>
</li>
</ol>
</li>
</ul>
<ol start="2">
<li>where &lt;表达式&gt; 可选，选用必须满足该项才可查询到。</li>
</ol>
<ul>
<li><ol>
<li><p>表达式条件1.比较，运算符。2.between and。 3.is null。4.is null 。5.like</p>
<pre><code>比如: select * from 数据表 where age=90;注意，此处不是赋值符号，等同于高级语言的==。
</code></pre>
</li>
</ol>
</li>
<li><ol start="2">
<li><p>多条件查询语句，使用 and(&amp;&amp;),or(||),XOR隔开。XOR意思是满足其中一个条件，不满足另一个条件，那么XOR成立。</p>
<pre><code>比如 select * from 数据表 where age=90 XOR height&gt;=180;会查询age=90,height&lt;180。和age!=90,height&gt;=180的值。
</code></pre>
</li>
</ol>
</li>
<li><ol start="3">
<li><p>like模糊查询[not] like ‘字符串’。注意like必须搭配where 使用。where条件为本字段。</p>
<pre><code>（1）select * from 表名 where name like&#39;a&#39;;

会匹配name=a的值。

(2)单值模糊查询_

select * from 表名 where name like&#39;_a&#39;;

会匹配name=?a的值。?可以等于a,b,c等任意单个值。

比如匹配aa,ba,fa

(3)多值模糊查询%

select * from 表名 where name like&#39;%a&#39;;

会匹配name=任意个?a的值。

比如aaa,hhhhkkkkkkkklllla.

(4)注意点:like不区大小写。要加binary

select * from 表名 where name like binary&#39;a&#39;;
</code></pre>
</li>
</ol>
</li>
<li><ol start="4">
<li><p>betwwen  X and Y。为查询X~Y范围这个范围内的数字</p>
<pre><code>比如select age from 表名 where between 10 and 20。会查询10~20直接的age.
</code></pre>
</li>
</ol>
</li>
<li><ol start="5">
<li><p>is [not] null查询是否为空值</p>
<pre><code>select * from 表名 where name is null。如果名字为空，会满足条件。

select * from 表名 where name is not null.如果名字不为空，满足条件。
</code></pre>
</li>
</ol>
</li>
</ul>
<ol start="3">
<li>group by&lt;字段&gt;可选，按照指定字段分组。</li>
</ol>
<ul>
<li><ol>
<li><p>group by &lt;字段名&gt;单独使用会显示每个分组的第一条记录。</p>
<pre><code>注：分组是依靠相同的值进行分组。
</code></pre>
</li>
</ol>
</li>
<li><ol start="2">
<li><p>group by与其他复合</p>
<pre><code>（1）group_concat()：该函数能够将所有值在一行打印。

select id,group_concat(name) from 表名  group by id。会依据id将所有的id相同的名字分成不同行。id为1的在同一行，id为2的在同一行。可以group_concat(distinct name)去重复，或者group_concat(name separator &quot;.&quot;)指定分割符号。

（2）group by与聚合函数：常用聚合函数有五种count()计算每组的元素数目。sum()计算每组的所有值相加。avg()计算每组的平均值。max()取出该组的最大值。min()取出该组的最小值。

sex   age

男     10

女     10

女      12

女      14

例子1.select sex count(age) from 表名 order  by  sex。意思是将男各分成一组，并且计算每组的人数。结果为

sex   age

男     1

女     3

sum()为age相加，

avg（）为age取平均数

max()和min()分别取最大值和最小值。

（3）with rollip会统计所有记录的总和。

比如以上select sex count(age) from 表名 order  by  sex with rollup。

最后得出的age值为4.如果使用sum,那么最后的值=10+(10+12+14)
</code></pre>
</li>
</ol>
</li>
</ul>
<ol start="4">
<li><p>[order by]&lt;字段&gt; 将查询出来的数据进行排序（比如升序，降序）。</p>
<pre><code>  英文升序全拼为:ascending order,简写asc。

  降序全拼为descending order,简写 desc
</code></pre>
</li>
</ol>
<ul>
<li><ol>
<li><p>格式:order by&lt;字段名&gt;[ASC|DESC]，注意，order by默认进行升序排序。</p>
<pre><code>select age from 表名 order by 字段名 [asc|desc]。如果age=&#123;3，1，2&#125;.asc后会变成&#123;1,2,3&#125;
</code></pre>
</li>
</ol>
</li>
<li><ol start="2">
<li><p>多字段排序</p>
<pre><code>select age,height from 表名 order by age  asc,height desc。会将依照age进行升序排序，之后依照height进行降序排序。
</code></pre>
</li>
</ol>
</li>
<li><ol start="3">
<li><p>关于非数字排序</p>
<pre><code>会将其转化成ascii值，然后对比进行排序。比如对(H,J,A)进行升序排序为(A,J,H),因为根据ascii值，A=65,J=74,H=72.
</code></pre>
</li>
</ol>
</li>
</ul>
<ol start="5">
<li><p>[LIMIT[&lt; offset&gt;]&lt; row count&gt;]每次显示查询的数据条数,一般用作分页</p>
<pre><code>注意，初始位置和记录数必须为整数
</code></pre>
</li>
</ol>
<ul>
<li><ol>
<li>格式1 : limit 初始位置，记录数 :select * from limit 3,5。意思是从第三行开始，返回5行数据。也就是返回3~8行的数据。</li>
</ol>
</li>
<li><ol start="2">
<li>格式2：limit 记录数:select * from limit 3 。这里没有指定初始值，默认从1开始，返回3行数据，也就是返回第一行到第3行数据。</li>
</ol>
</li>
<li><ol start="3">
<li>格式3：limit 记录数 offset 初始位置:select * from limit 3 offset 5&#x3D;:select * from limit 3,5也就是格式1。</li>
</ol>
</li>
</ul>
<ol start="6">
<li><p>having：过滤分组与where功能类似，但使用条件是形式有不同。</p>
<p>   having和where主要区别：having是针对已经查询完返回的记录进行分组。where是对查询时的数组进行分组。</p>
<p>   这两者的区别也使得where是无法使用聚合函数和字段别名的，因为在查询数据时无法对数据经行聚合和改别名等操作。</p>
<p>   其次select a from表名 where b&#x3D;1;不会一定会报错，但是having b&#x3D;1一定会报错。因为having是针对返回的查询结果进行筛选。而返回的结果中没有b。</p>
</li>
<li><p>连接查询</p>
<p>   连接查询分为3种，1.交叉连接 (cross join,简写直接使用，分割表即可)。2.内连接( 表名 inner join 表名 on,简写可以省略inner)3.外连接，分为左外连接和右外连接(表1{left|right} outer join 表2 [on 条件] ，简写可省略outer)。</p>
</li>
</ol>
<ul>
<li><p>1.交叉连接，使用where查询，会将两张表拼接成一张表，在数目大时，造成的笛卡尔乘积会非常大。</p>
</li>
<li><p>2.内连接，对两张表的值进行匹配，不成功的不保留。</p>
</li>
<li><p>3.外连接，左外连接以左表为基表，使其与右边参照表匹配，会保留左表的全部匹配记录，未匹配未null。右外连接则相反。</p>
<pre><code>连接查询如果两个表有重名字段需加上表.字段名。
</code></pre>
</li>
</ul>
<ol start="8">
<li><p>子查询 where &lt;表达式&gt; &lt;操作符&gt;(子查询)</p>
<p>   例子1.select name from 表名 where id in(selct id from 表2 where cours_name&#x3D;’java’)。</p>
<p>   in为操作符</p>
<p>   ()中为子表</p>
</li>
</ol>
<ul>
<li><ol>
<li>主要4中操作符(1)in判断子集的返回集的某个值是否相等，相等true,反之false (2)not in是否不相等 (3)exists是否存在，存在true,不存在false（4)not exists,是否为空</li>
</ol>
</li>
<li><ol start="2">
<li><p>子集查询需注意点</p>
<p> (1)子查询select子句</p>
<p> select (子查询) from 表名。</p>
<p> (2)子查询from子句子查询</p>
<p> select * from (子查询) as别名。必须指定别名，创建一张临时表。</p>
<p> （9）union:用于合并两个结果集，union会自动过滤重名，要显示全部用union all</p>
<p> SELECT column_name(s) FROM table_name1<br> UNION<br> SELECT column_name(s) FROM table_name2</p>
</li>
</ol>
</li>
</ul>
<hr>
<h2 id="8-其他数据操作"><a href="#8-其他数据操作" class="headerlink" title="8.其他数据操作"></a>8.其他数据操作</h2><ol>
<li>插入数据：<br>两种形式(1)insert …values(2)insert …set…</li>
</ol>
<ul>
<li><ol>
<li>insert into &lt;表名&gt; [列名1，2]values (值1，2):<br>此方法列名不是必选项是因为，如果不指定列名，则默认依次全部赋值。</li>
</ol>
</li>
</ul>
<p>例子：insert into 表名 (id) value (1);<br>可以一次插入多条<br>insert into 表名 (id) value (1),(2),(3);或者<br>insert into 表名 (id) select () union selct ()…</p>
<ul>
<li><ol start="2">
<li>insert into &lt;表名&gt; set &lt;列名1&gt;&#x3D;&lt;值1&gt;,&lt;列2&gt;&#x3D;&lt;值2&gt;…<br>例子:insert into 表名 set id&#x3D;1;<br>值得注意的是，insert可以快速将整个结果集插入多行，比如快速复制另一表的全部数据，但是两个表的每段的字段数，类型必须一致。<br>例子insert into 表1 (字段)select * from 表2;</li>
</ol>
</li>
<li><ol start="3">
<li>修改(更新)数据<br>update&lt;表名&gt; set字段1&#x3D;值1,[字段2…] [where子句 ] [order by] [limit]<br>where筛选出可以更新的值，order by用于被修改的次序，limit限定被修改的行数。<br>例子：update 表名 set id&#x3D;1;</li>
</ol>
</li>
</ul>
<ol start="2">
<li>删除数据</li>
</ol>
<ul>
<li><ol>
<li>删除表中全部数据: [where子句 ] [order by] [limit]<br>例子： delete from 表名。</li>
</ol>
</li>
<li><ol start="2">
<li>删除表中指定数据delete from &lt;表名&gt; [where子句 ] [order by] [limit]<br>例子:delete from 表名 where id&#x3D;4;</li>
</ol>
</li>
<li><ol start="3">
<li>清空表数据：truncat [table]表名<br>truncat 表名；</li>
</ol>
</li>
</ul>
<hr>
<h2 id="9-关系模型范式介绍与选择"><a href="#9-关系模型范式介绍与选择" class="headerlink" title="9.关系模型范式介绍与选择:"></a>9.关系模型范式介绍与选择:</h2><pre><code>  首先介绍超键，候选键，主键。

  元组:可以理解为行，也就是一组字段。

  属性：非主键字段。

   **超键(super key):**在关系中能唯一标识元组的属性集称为关系模式的超键
  **候选键(candidate key):**不含有多余属性的超键称为候选键
  **主键(primary key):**用户选作元组标识的一个候选键程序主键。

  主键是候选键其中的一个。候选键是特殊的超键。主键是特殊的超键中的一个。

  

  

  关系模型范式分为：第一范式（1NF），第二范式(2NF)，第三范式(3NF)和BCFN.

  BCNF又称修正第三范式。

  (1)须知:1. 在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。并且DBMS不可能让你使用数据库做出不符合关系数据库的模式。2.第一范式为基础范式，要做出第二范式必须先满足第一范式，要做出第三范式必须先满足第一和第二范式。

  (1)第一范式(1FN)：  是指数据库表的每一列都是不可分割的基本数据项 。

  人话:也就是说没有重复的列（字段）。

  比如字段id，姓名。就符合第一范式。字段id,id,姓名不符合第一范式。你也无法用数据库在同一个表中创建两个名字相同的字段。

  (2)第二范式(2FN)： 再提醒一遍，第二范式必须满足(包涵)第一范式。

  第二范式就是非主属性非部分依赖于主关键字。 

  人话:每个主属性(每个表的主键)必须完全影响与该主键有关联的属性(非主键字段)。

  比如关键字组合(也就是联合主键)(学号，课程名称)-&gt; 其他属性(其他字段)(姓名, 年龄, 成绩, 学分) .就不满足第二范式。

  因为主键学号会影响与学号无关的成绩，课程会影响学姓名，年龄。

  正确的应该是将此表分成三部分1.学生表。2,课程表。3，学生选的课程表成绩

  对于联合主键(a,b)。a,b中的任意主键都必须对属性产生完全影响才可以为第二范式，也就是a,b都与任意的属性有关系。

  联合主键和候选键区别，联合主键是多个字段确定唯一，候选键可以是一个字段确定唯一。

  （3）第三范式(3FN): 属性不依赖于其它非主属性。 

  人话:每个属性除了和主属性之间没有关系。

  比如: (学号) → (姓名, 年龄, 所在学院, 学院地点, 学院电话) 不符合第三范式

   　 因为:(学号) → (所在学院) → (学院地点, 学院电话) ‘

  (4)BCFN与第三范式关系。

  1.如果该关系属于BCFN，那么该关系一定属于第三范式，反之不然。

  2.区别:第三范式仅仅要求非主属性之间不能存在依赖。但BCFN要求候选键(可以理解为主键，不过实际范围更广)之间也不能存在依赖。
</code></pre>
<hr>
<h2 id="10-数据库E-R图"><a href="#10-数据库E-R图" class="headerlink" title="10. 数据库E-R图:"></a>10. 数据库E-R图:</h2><pre><code>      （1）基础介绍:1.实体:矩形表示。2.属性:椭圆表示。3.关系:菱形表示。4.联系：实线。

      5.对应关系:用字母或者数字写，只能用于实体和关系之间。在实线旁边写。1代表一个实体对应一个关系，n,m,p等任意字母代表多对多哦。

      （2）E-R图与数据库联系

      ​    1.实体：表名。2.属性:表中字段。3.关系一般是以连接的表作为外键的表名。

      (3)E-R图转关系模型联系

      实体(属性，属性) 主码；

      主码需要从E_R图转数据库分析出主键。

      
</code></pre>
<h2 id="11-视图：一种虚拟存在的表，与这真实表一样，视图也由列和行构成，但视图并不实际存放数据。其数据来自于定义视图的查询中所使用的表，并且还是在使用视图时动态生成。-。一旦真实表中的数据发生改变，显示在视图中的数据也会发生改变。"><a href="#11-视图：一种虚拟存在的表，与这真实表一样，视图也由列和行构成，但视图并不实际存放数据。其数据来自于定义视图的查询中所使用的表，并且还是在使用视图时动态生成。-。一旦真实表中的数据发生改变，显示在视图中的数据也会发生改变。" class="headerlink" title="11. 视图：一种虚拟存在的表，与这真实表一样，视图也由列和行构成，但视图并不实际存放数据。其数据来自于定义视图的查询中所使用的表，并且还是在使用视图时动态生成。 。一旦真实表中的数据发生改变，显示在视图中的数据也会发生改变。"></a>11. 视图：一种虚拟存在的表，与这真实表一样，视图也由列和行构成，但视图并不实际存放数据。其数据来自于定义视图的查询中所使用的表，并且还是在使用视图时动态生成。 。一旦真实表中的数据发生改变，显示在视图中的数据也会发生改变。</h2><pre><code>       视图可以从原有的表上选取对用户有用的信息，那些对用户没用，或者用户没有权限了解的信息，都可以直接屏蔽掉，作用类似于筛选。这样做既使应用简单化，也保证了系统的安全。

       视图与表在本质上虽然不相同，但视图经过定义以后，结构形式和表一样，可以进行查询、修改、更新和删除等操作。 

      优点:1.简化数据2.安全3.共享 

      （1）创建视图

      create view &lt;名字&gt; as &lt;select语句&gt; 注意，视图名字必须唯一，select语句用于指定数据源。

      值得注意的是，select不能包涵from的子句子查询（可以多表查询，不要混淆）。select不能引用系统用户变量，不能处理预处理语句。不能引用临时表。

      可以使用check table检查是否存在。

      （2）查看视图descibe &lt;视图名字&gt;，查看详细信息 shwo create view &lt;视图名字&gt;

      （3）修改视图 alter view &lt;视图名&gt; as &lt;select语句&gt;，使用了聚合函数，distinct,groupby,having,union,union all，where,from，临时表不可以修改。

      否则可以insert,update,delete等更新。

      如果要修改名字，请删除重新创建，可以使用insert into t values slect* from t2快速更新。

      (4)删除视图 drop view if exists &lt;vname&gt;
</code></pre>
<h2 id="12-索引：索引是一种特殊的数据库结构，由数据库的一列或者多列组合而成。用来快速查询数据库中的某一特定记录。"><a href="#12-索引：索引是一种特殊的数据库结构，由数据库的一列或者多列组合而成。用来快速查询数据库中的某一特定记录。" class="headerlink" title="12. 索引：索引是一种特殊的数据库结构，由数据库的一列或者多列组合而成。用来快速查询数据库中的某一特定记录。"></a>12. 索引：索引是一种特殊的数据库结构，由数据库的一列或者多列组合而成。用来快速查询数据库中的某一特定记录。</h2><pre><code>      数据库访问行数据方式:1:顺序访问。2.索引访问。

      优点：减少查询时间。缺点：增加维护成本。

      (1)创建索引:

      1.create &lt;索引名&gt; on &lt;表名&gt; (&lt;列名&gt;[&lt;长度&gt;] [ASC|DESC]&#125;)

      2.在创建表时创建索引 create table &lt;表名&gt; (id int,index(id))。

      创建唯一索引 unique index(id)

      3.使用alter table 创建索引

      alter table &lt;表名&gt; add index（[&lt;索引名&gt;] [&lt;索引类型&gt;]）(&lt;列名&gt;)

      (2.)查看索引.show index from &lt;表名&gt; [from&lt;数据库名&gt;]

      show index from tablename.

      (3)mysql修改和删除索引

      1.drop index &lt;索引名&gt; on &lt;表名&gt;

      drop index id on user

      
</code></pre>
<h2 id="13-补充"><a href="#13-补充" class="headerlink" title="13.补充"></a>13.补充</h2><pre><code>  以下是关于关系模型分解的补充。

  (1)函数依赖: 关系模型函数依赖集&#123;A-&gt;BC , CD-&gt;E , B-&gt;D , BE-&gt;F , EF-&gt;A&#125; ，在关系模型

  分解后依然保持此依赖关系。

  (2)无损连接： 无损联接分解是将一个关系模式分解成若干个关系模式后，通过自然联接和投影等运算仍能还原到原来的关系模式，则称这种分解为无损联接分解。 

  人话就是:函按照分解部分的函数依赖依旧可以存在，那么就无损。

  

  

  

  

    

  























  
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yuanSchuan</p>
  <div class="site-description" itemprop="description">既然选择远方，便不顾风雨亦兼程</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yuanSchuan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
